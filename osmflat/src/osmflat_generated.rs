// Do not edit: This code was generated by flatdata's generator.
#[allow(missing_docs)]
pub mod osm {

    #[doc(hidden)]
    pub mod schema {
        pub mod structs {
            pub const HEADER: &str = r#"namespace osm {
struct Header
{
    bbox_left : i64 : 40;
    bbox_right : i64 : 40;
    bbox_top : i64 : 40;
    bbox_bottom : i64 : 40;
    required_feature_first_idx : u64 : 40;
    required_features_size : u32 : 4;
    optional_feature_first_idx : u64 : 40;
    optional_features_size : u32 : 4;
    writingprogram_idx : u64 : 40;
    source_idx : u64 : 40;
    osmosis_replication_timestamp : i64 : 64;
    osmosis_replication_sequence_number : i64 : 64;
    osmosis_replication_base_url_idx : u64 : 40;
}
}

"#;
            pub const TAG: &str = r#"namespace osm {
struct Tag
{
    key_idx : u64 : 40;
    value_idx : u64 : 40;
}
}

"#;
            pub const NODE: &str = r#"namespace osm {
struct Node
{
    id : i64 : 40;
    lat : i64 : 40;
    lon : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
}
}

"#;
            pub const NODE_INDEX: &str = r#"namespace osm {
struct NodeIndex
{
    value : u64 : 40;
}
}

"#;
            pub const WAY: &str = r#"namespace osm {
struct Way
{
    id : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
    @range( refs )
    ref_first_idx : u64 : 40;
}
}

"#;
            pub const TAG_INDEX: &str = r#"namespace osm {
struct TagIndex
{
    value : u64 : 40;
}
}

"#;
            pub const NODE_MEMBER: &str = r#"namespace osm {
struct NodeMember
{
    node_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

"#;
            pub const WAY_MEMBER: &str = r#"namespace osm {
struct WayMember
{
    way_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

"#;
            pub const RELATION_MEMBER: &str = r#"namespace osm {
struct RelationMember
{
    relation_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

"#;
            pub const RELATION: &str = r#"namespace osm {
struct Relation
{
    id : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
}
}

"#;
        }

        pub mod osm {

            pub const OSM: &str = r#"namespace osm {
struct Header
{
    bbox_left : i64 : 40;
    bbox_right : i64 : 40;
    bbox_top : i64 : 40;
    bbox_bottom : i64 : 40;
    required_feature_first_idx : u64 : 40;
    required_features_size : u32 : 4;
    optional_feature_first_idx : u64 : 40;
    optional_features_size : u32 : 4;
    writingprogram_idx : u64 : 40;
    source_idx : u64 : 40;
    osmosis_replication_timestamp : i64 : 64;
    osmosis_replication_sequence_number : i64 : 64;
    osmosis_replication_base_url_idx : u64 : 40;
}
}

namespace osm {
struct Node
{
    id : i64 : 40;
    lat : i64 : 40;
    lon : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
}
}

namespace osm {
struct Way
{
    id : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
    @range( refs )
    ref_first_idx : u64 : 40;
}
}

namespace osm {
struct Relation
{
    id : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
}
}

namespace osm {
struct NodeMember
{
    node_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
struct WayMember
{
    way_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
struct RelationMember
{
    relation_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
struct Tag
{
    key_idx : u64 : 40;
    value_idx : u64 : 40;
}
}

namespace osm {
struct TagIndex
{
    value : u64 : 40;
}
}

namespace osm {
struct NodeIndex
{
    value : u64 : 40;
}
}

namespace osm {
const u64 INVALID_IDX = 1099511627775;
}

namespace osm {
const u64 COORD_SCALE = 1000000000;
}

namespace osm {
@bound_implicitly( Relations : .osm.Osm.relations, .osm.Osm.relation_members )
archive Osm
{
    @explicit_reference( .osm.Header.required_feature_first_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.optional_feature_first_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.writingprogram_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.source_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.osmosis_replication_base_url_idx, .osm.Osm.stringtable )
    header : .osm.Header;
    @explicit_reference( .osm.Node.tag_first_idx, .osm.Osm.tags_index )
    nodes : vector< .osm.Node >;
    @explicit_reference( .osm.Way.tag_first_idx, .osm.Osm.tags_index )
    @explicit_reference( .osm.Way.ref_first_idx, .osm.Osm.nodes_index )
    ways : vector< .osm.Way >;
    @explicit_reference( .osm.Relation.tag_first_idx, .osm.Osm.tags_index )
    relations : vector< .osm.Relation >;
    @explicit_reference( .osm.NodeMember.node_idx, .osm.Osm.nodes )
    @explicit_reference( .osm.NodeMember.role_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.WayMember.way_idx, .osm.Osm.ways )
    @explicit_reference( .osm.WayMember.role_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.RelationMember.relation_idx, .osm.Osm.relations )
    @explicit_reference( .osm.RelationMember.role_idx, .osm.Osm.stringtable )
    relation_members : multivector< 40, .osm.NodeMember, .osm.WayMember, .osm.RelationMember >;
    @explicit_reference( .osm.Tag.key_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Tag.value_idx, .osm.Osm.stringtable )
    tags : vector< .osm.Tag >;
    @explicit_reference( .osm.TagIndex.value, .osm.Osm.tags )
    tags_index : vector< .osm.TagIndex >;
    @explicit_reference( .osm.NodeIndex.value, .osm.Osm.nodes )
    nodes_index : vector< .osm.NodeIndex >;
    stringtable : raw_data;
}
}

"#;

            pub mod resources {
                pub const HEADER: &str = r#"namespace osm {
struct Header
{
    bbox_left : i64 : 40;
    bbox_right : i64 : 40;
    bbox_top : i64 : 40;
    bbox_bottom : i64 : 40;
    required_feature_first_idx : u64 : 40;
    required_features_size : u32 : 4;
    optional_feature_first_idx : u64 : 40;
    optional_features_size : u32 : 4;
    writingprogram_idx : u64 : 40;
    source_idx : u64 : 40;
    osmosis_replication_timestamp : i64 : 64;
    osmosis_replication_sequence_number : i64 : 64;
    osmosis_replication_base_url_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.Header.required_feature_first_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.optional_feature_first_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.writingprogram_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.source_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.osmosis_replication_base_url_idx, .osm.Osm.stringtable )
    header : .osm.Header;
}
}

"#;
                pub const NODES: &str = r#"namespace osm {
struct Node
{
    id : i64 : 40;
    lat : i64 : 40;
    lon : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.Node.tag_first_idx, .osm.Osm.tags_index )
    nodes : vector< .osm.Node >;
}
}

"#;
                pub const WAYS: &str = r#"namespace osm {
struct Way
{
    id : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
    @range( refs )
    ref_first_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.Way.tag_first_idx, .osm.Osm.tags_index )
    @explicit_reference( .osm.Way.ref_first_idx, .osm.Osm.nodes_index )
    ways : vector< .osm.Way >;
}
}

"#;
                pub const RELATIONS: &str = r#"namespace osm {
struct Relation
{
    id : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.Relation.tag_first_idx, .osm.Osm.tags_index )
    relations : vector< .osm.Relation >;
}
}

"#;
                pub const RELATION_MEMBERS: &str = r#"namespace osm {
struct NodeMember
{
    node_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
struct WayMember
{
    way_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
struct RelationMember
{
    relation_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.NodeMember.node_idx, .osm.Osm.nodes )
    @explicit_reference( .osm.NodeMember.role_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.WayMember.way_idx, .osm.Osm.ways )
    @explicit_reference( .osm.WayMember.role_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.RelationMember.relation_idx, .osm.Osm.relations )
    @explicit_reference( .osm.RelationMember.role_idx, .osm.Osm.stringtable )
    relation_members : multivector< 40, .osm.NodeMember, .osm.WayMember, .osm.RelationMember >;
}
}

"#;
                pub const TAGS: &str = r#"namespace osm {
struct Tag
{
    key_idx : u64 : 40;
    value_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.Tag.key_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Tag.value_idx, .osm.Osm.stringtable )
    tags : vector< .osm.Tag >;
}
}

"#;
                pub const TAGS_INDEX: &str = r#"namespace osm {
struct TagIndex
{
    value : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.TagIndex.value, .osm.Osm.tags )
    tags_index : vector< .osm.TagIndex >;
}
}

"#;
                pub const NODES_INDEX: &str = r#"namespace osm {
struct NodeIndex
{
    value : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.NodeIndex.value, .osm.Osm.nodes )
    nodes_index : vector< .osm.NodeIndex >;
}
}

"#;
                pub const STRINGTABLE: &str = r#"namespace osm {
archive Osm
{
    stringtable : raw_data;
}
}

"#;
            }
        }
    }
    /// Special value which represents an invalid index.
    pub const INVALID_IDX: u64 = 1_099_511_627_775;

    /// All coordinate are scaled by this constant to convert them to integers.
    pub const COORD_SCALE: u64 = 1_000_000_000;
    /// Metadata attached to the archive.
    #[repr(transparent)]
    #[derive(Clone)]
    pub struct Header {
        data: [u8; 62],
    }

    impl Header {
        /// Unsafe since the struct might not be self-contained
        pub unsafe fn new_unchecked() -> Self {
            Self { data: [0; 62] }
        }
    }

    impl flatdata::Struct for Header {
        unsafe fn create_unchecked() -> Self {
            Self { data: [0; 62] }
        }

        const SCHEMA: &'static str = schema::structs::HEADER;
        const SIZE_IN_BYTES: usize = 62;
        const IS_OVERLAPPING_WITH_NEXT: bool = false;
    }

    impl Header {
        pub fn new() -> Self {
            Self { data: [0; 62] }
        }

        /// Create reference from byte array of matching size
        pub fn from_bytes(data: &[u8; 62]) -> &Self {
            // Safety: This is safe since Header is repr(transparent)
            unsafe { std::mem::transmute(data) }
        }

        /// Create reference from byte array of matching size
        pub fn from_bytes_mut(data: &mut [u8; 62]) -> &mut Self {
            // Safety: This is safe since Header is repr(transparent)
            unsafe { std::mem::transmute(data) }
        }

        /// Create reference from byte array
        pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
            // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
            if data.len() < 62 {
                assert_eq!(data.len(), 62);
                return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
            }
            let ptr = data.as_ptr() as *const [u8; 62];
            // Safety: We checked length before
            Ok(Self::from_bytes(unsafe { &*ptr }))
        }

        /// Create reference from byte array
        pub fn from_bytes_slice_mut(
            data: &mut [u8],
        ) -> Result<&mut Self, flatdata::ResourceStorageError> {
            // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
            if data.len() < 62 {
                assert_eq!(data.len(), 62);
                return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
            }
            let ptr = data.as_ptr() as *mut [u8; 62];
            // Safety: We checked length before
            Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
        }

        pub fn as_bytes(&self) -> &[u8; 62] {
            &self.data
        }
    }

    impl Default for Header {
        fn default() -> Self {
            Self::new()
        }
    }

    impl flatdata::NoOverlap for Header {}

    impl Header {
        /// Bounding box (min longitude scaled with `COORD_SCALE`)
        #[inline]
        pub fn bbox_left(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 0, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// Bounding box (max longitude scaled with `COORD_SCALE`)
        #[inline]
        pub fn bbox_right(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 40, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// Bounding box (max latitude scaled with `COORD_SCALE`)
        #[inline]
        pub fn bbox_top(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 80, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// Bounding box (min latitude scaled with `COORD_SCALE`)
        #[inline]
        pub fn bbox_bottom(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 120, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// Reference to the first required feature in `stringtable`.
        #[inline]
        pub fn required_feature_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 160, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Number of required features.
        #[inline]
        pub fn required_features_size(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data.as_ptr(), 200, 4);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }

        /// Reference to the first optional feature in `stringtable`.
        #[inline]
        pub fn optional_feature_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 204, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Number of optional features.
        #[inline]
        pub fn optional_features_size(&self) -> u32 {
            let value = flatdata_read_bytes!(u32, self.data.as_ptr(), 244, 4);
            unsafe { std::mem::transmute::<u32, u32>(value) }
        }

        /// Writing program used to write the data (reference to `stringtable`).
        #[inline]
        pub fn writingprogram_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 248, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// The origin (source) of the data.
        #[inline]
        pub fn source_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 288, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Replication timestamp, expressed in seconds since the epoch.
        /// See [`state.txt`].
        ///
        /// [`state.txt`]: https://wiki.openstreetmap.org/wiki/Planet.osm/diffs#Minute.2C_Hour.2C_and_Day_Files_Organisation
        #[inline]
        pub fn osmosis_replication_timestamp(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 328, 64);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// Replication sequence number (`sequenceNumber` from [`state.txt`]).
        ///
        /// [`state.txt`]: https://wiki.openstreetmap.org/wiki/Planet.osm/diffs#Minute.2C_Hour.2C_and_Day_Files_Organisation
        #[inline]
        pub fn osmosis_replication_sequence_number(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 392, 64);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// Replication base URL (reference to `stringtable`).
        #[inline]
        pub fn osmosis_replication_base_url_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 456, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }
    }

    impl std::fmt::Debug for Header {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("Header")
                .field("bbox_left", &self.bbox_left())
                .field("bbox_right", &self.bbox_right())
                .field("bbox_top", &self.bbox_top())
                .field("bbox_bottom", &self.bbox_bottom())
                .field(
                    "required_feature_first_idx",
                    &self.required_feature_first_idx(),
                )
                .field("required_features_size", &self.required_features_size())
                .field(
                    "optional_feature_first_idx",
                    &self.optional_feature_first_idx(),
                )
                .field("optional_features_size", &self.optional_features_size())
                .field("writingprogram_idx", &self.writingprogram_idx())
                .field("source_idx", &self.source_idx())
                .field(
                    "osmosis_replication_timestamp",
                    &self.osmosis_replication_timestamp(),
                )
                .field(
                    "osmosis_replication_sequence_number",
                    &self.osmosis_replication_sequence_number(),
                )
                .field(
                    "osmosis_replication_base_url_idx",
                    &self.osmosis_replication_base_url_idx(),
                )
                .finish()
        }
    }

    impl std::cmp::PartialEq for Header {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.bbox_left() == other.bbox_left()
                && self.bbox_right() == other.bbox_right()
                && self.bbox_top() == other.bbox_top()
                && self.bbox_bottom() == other.bbox_bottom()
                && self.required_feature_first_idx() == other.required_feature_first_idx()
                && self.required_features_size() == other.required_features_size()
                && self.optional_feature_first_idx() == other.optional_feature_first_idx()
                && self.optional_features_size() == other.optional_features_size()
                && self.writingprogram_idx() == other.writingprogram_idx()
                && self.source_idx() == other.source_idx()
                && self.osmosis_replication_timestamp() == other.osmosis_replication_timestamp()
                && self.osmosis_replication_sequence_number()
                    == other.osmosis_replication_sequence_number()
                && self.osmosis_replication_base_url_idx()
                    == other.osmosis_replication_base_url_idx()
        }
    }

    impl Header {
        /// Bounding box (min longitude scaled with `COORD_SCALE`)
        #[inline]
        #[allow(missing_docs)]
        pub fn set_bbox_left(&mut self, value: i64) {
            flatdata_write_bytes!(i64; value, self.data, 0, 40)
        }

        /// Bounding box (max longitude scaled with `COORD_SCALE`)
        #[inline]
        #[allow(missing_docs)]
        pub fn set_bbox_right(&mut self, value: i64) {
            flatdata_write_bytes!(i64; value, self.data, 40, 40)
        }

        /// Bounding box (max latitude scaled with `COORD_SCALE`)
        #[inline]
        #[allow(missing_docs)]
        pub fn set_bbox_top(&mut self, value: i64) {
            flatdata_write_bytes!(i64; value, self.data, 80, 40)
        }

        /// Bounding box (min latitude scaled with `COORD_SCALE`)
        #[inline]
        #[allow(missing_docs)]
        pub fn set_bbox_bottom(&mut self, value: i64) {
            flatdata_write_bytes!(i64; value, self.data, 120, 40)
        }

        /// Reference to the first required feature in `stringtable`.
        #[inline]
        #[allow(missing_docs)]
        pub fn set_required_feature_first_idx(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 160, 40)
        }

        /// Number of required features.
        #[inline]
        #[allow(missing_docs)]
        pub fn set_required_features_size(&mut self, value: u32) {
            flatdata_write_bytes!(u32; value, self.data, 200, 4)
        }

        /// Reference to the first optional feature in `stringtable`.
        #[inline]
        #[allow(missing_docs)]
        pub fn set_optional_feature_first_idx(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 204, 40)
        }

        /// Number of optional features.
        #[inline]
        #[allow(missing_docs)]
        pub fn set_optional_features_size(&mut self, value: u32) {
            flatdata_write_bytes!(u32; value, self.data, 244, 4)
        }

        /// Writing program used to write the data (reference to `stringtable`).
        #[inline]
        #[allow(missing_docs)]
        pub fn set_writingprogram_idx(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 248, 40)
        }

        /// The origin (source) of the data.
        #[inline]
        #[allow(missing_docs)]
        pub fn set_source_idx(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 288, 40)
        }

        /// Replication timestamp, expressed in seconds since the epoch.
        /// See [`state.txt`].
        ///
        /// [`state.txt`]: https://wiki.openstreetmap.org/wiki/Planet.osm/diffs#Minute.2C_Hour.2C_and_Day_Files_Organisation
        #[inline]
        #[allow(missing_docs)]
        pub fn set_osmosis_replication_timestamp(&mut self, value: i64) {
            flatdata_write_bytes!(i64; value, self.data, 328, 64)
        }

        /// Replication sequence number (`sequenceNumber` from [`state.txt`]).
        ///
        /// [`state.txt`]: https://wiki.openstreetmap.org/wiki/Planet.osm/diffs#Minute.2C_Hour.2C_and_Day_Files_Organisation
        #[inline]
        #[allow(missing_docs)]
        pub fn set_osmosis_replication_sequence_number(&mut self, value: i64) {
            flatdata_write_bytes!(i64; value, self.data, 392, 64)
        }

        /// Replication base URL (reference to `stringtable`).
        #[inline]
        #[allow(missing_docs)]
        pub fn set_osmosis_replication_base_url_idx(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 456, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &Header) {
            self.set_bbox_left(other.bbox_left());
            self.set_bbox_right(other.bbox_right());
            self.set_bbox_top(other.bbox_top());
            self.set_bbox_bottom(other.bbox_bottom());
            self.set_required_feature_first_idx(other.required_feature_first_idx());
            self.set_required_features_size(other.required_features_size());
            self.set_optional_feature_first_idx(other.optional_feature_first_idx());
            self.set_optional_features_size(other.optional_features_size());
            self.set_writingprogram_idx(other.writingprogram_idx());
            self.set_source_idx(other.source_idx());
            self.set_osmosis_replication_timestamp(other.osmosis_replication_timestamp());
            self.set_osmosis_replication_sequence_number(
                other.osmosis_replication_sequence_number(),
            );
            self.set_osmosis_replication_base_url_idx(other.osmosis_replication_base_url_idx());
        }
    }
    /// A `(key, value)` attached to a `Node`, `Way`, or `Relation.
    #[repr(transparent)]
    #[derive(Clone)]
    pub struct Tag {
        data: [u8; 10],
    }

    impl Tag {
        /// Unsafe since the struct might not be self-contained
        pub unsafe fn new_unchecked() -> Self {
            Self { data: [0; 10] }
        }
    }

    impl flatdata::Struct for Tag {
        unsafe fn create_unchecked() -> Self {
            Self { data: [0; 10] }
        }

        const SCHEMA: &'static str = schema::structs::TAG;
        const SIZE_IN_BYTES: usize = 10;
        const IS_OVERLAPPING_WITH_NEXT: bool = false;
    }

    impl Tag {
        pub fn new() -> Self {
            Self { data: [0; 10] }
        }

        /// Create reference from byte array of matching size
        pub fn from_bytes(data: &[u8; 10]) -> &Self {
            // Safety: This is safe since Tag is repr(transparent)
            unsafe { std::mem::transmute(data) }
        }

        /// Create reference from byte array of matching size
        pub fn from_bytes_mut(data: &mut [u8; 10]) -> &mut Self {
            // Safety: This is safe since Tag is repr(transparent)
            unsafe { std::mem::transmute(data) }
        }

        /// Create reference from byte array
        pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
            // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
            if data.len() < 10 {
                assert_eq!(data.len(), 10);
                return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
            }
            let ptr = data.as_ptr() as *const [u8; 10];
            // Safety: We checked length before
            Ok(Self::from_bytes(unsafe { &*ptr }))
        }

        /// Create reference from byte array
        pub fn from_bytes_slice_mut(
            data: &mut [u8],
        ) -> Result<&mut Self, flatdata::ResourceStorageError> {
            // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
            if data.len() < 10 {
                assert_eq!(data.len(), 10);
                return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
            }
            let ptr = data.as_ptr() as *mut [u8; 10];
            // Safety: We checked length before
            Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
        }

        pub fn as_bytes(&self) -> &[u8; 10] {
            &self.data
        }
    }

    impl Default for Tag {
        fn default() -> Self {
            Self::new()
        }
    }

    impl flatdata::NoOverlap for Tag {}

    impl Tag {
        /// Key index in `stringtable`
        #[inline]
        pub fn key_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Value index in `stringtable`
        #[inline]
        pub fn value_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }
    }

    impl std::fmt::Debug for Tag {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("Tag")
                .field("key_idx", &self.key_idx())
                .field("value_idx", &self.value_idx())
                .finish()
        }
    }

    impl std::cmp::PartialEq for Tag {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.key_idx() == other.key_idx() && self.value_idx() == other.value_idx()
        }
    }

    impl Tag {
        /// Key index in `stringtable`
        #[inline]
        #[allow(missing_docs)]
        pub fn set_key_idx(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 0, 40)
        }

        /// Value index in `stringtable`
        #[inline]
        #[allow(missing_docs)]
        pub fn set_value_idx(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 40, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &Tag) {
            self.set_key_idx(other.key_idx());
            self.set_value_idx(other.value_idx());
        }
    }
    /// A node is one of the core elements in the OpenStreetMap data model.
    ///
    /// It consists of a single point in space defined by its latitude, longitude and node id.
    ///
    /// See <https://wiki.openstreetmap.org/wiki/Node>.
    #[repr(transparent)]
    pub struct Node {
        data: [u8; 20],
    }

    impl Node {
        /// Unsafe since the struct might not be self-contained
        pub unsafe fn new_unchecked() -> Self {
            Self { data: [0; 20] }
        }
    }

    impl flatdata::Struct for Node {
        unsafe fn create_unchecked() -> Self {
            Self { data: [0; 20] }
        }

        const SCHEMA: &'static str = schema::structs::NODE;
        const SIZE_IN_BYTES: usize = 20;
        const IS_OVERLAPPING_WITH_NEXT: bool = true;
    }

    impl Node {
        /// Unique node ID
        #[inline]
        pub fn id(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 0, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// Latitude (scaled with `COORD_SCALE`).
        #[inline]
        pub fn lat(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 40, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// Longitude (scaled with `COORD_SCALE`).
        #[inline]
        pub fn lon(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 80, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// First element of the range [`tags`].
        ///
        /// [`tags`]: #method.tags
        #[inline]
        pub fn tag_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 120, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Range of tags attached to this node.
        ///
        /// The values of the range are indexes in the `tags_index` vector.
        #[inline]
        pub fn tags(&self) -> std::ops::Range<u64> {
            let start = flatdata_read_bytes!(u64, self.data.as_ptr(), 120, 40);
            let end = flatdata_read_bytes!(u64, self.data.as_ptr(), 120 + 20 * 8, 40);
            start..end
        }
    }

    impl std::fmt::Debug for Node {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("Node")
                .field("id", &self.id())
                .field("lat", &self.lat())
                .field("lon", &self.lon())
                .field("tag_first_idx", &self.tag_first_idx())
                .finish()
        }
    }

    impl std::cmp::PartialEq for Node {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.id() == other.id()
                && self.lat() == other.lat()
                && self.lon() == other.lon()
                && self.tag_first_idx() == other.tag_first_idx()
        }
    }

    impl Node {
        /// Unique node ID
        #[inline]
        #[allow(missing_docs)]
        pub fn set_id(&mut self, value: i64) {
            flatdata_write_bytes!(i64; value, self.data, 0, 40)
        }

        /// Latitude (scaled with `COORD_SCALE`).
        #[inline]
        #[allow(missing_docs)]
        pub fn set_lat(&mut self, value: i64) {
            flatdata_write_bytes!(i64; value, self.data, 40, 40)
        }

        /// Longitude (scaled with `COORD_SCALE`).
        #[inline]
        #[allow(missing_docs)]
        pub fn set_lon(&mut self, value: i64) {
            flatdata_write_bytes!(i64; value, self.data, 80, 40)
        }

        /// First element of the range [`tags`].
        ///
        /// [`tags`]: struct.NodeRef.html#method.tags
        #[inline]
        #[allow(missing_docs)]
        pub fn set_tag_first_idx(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 120, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &Node) {
            self.set_id(other.id());
            self.set_lat(other.lat());
            self.set_lon(other.lon());
            self.set_tag_first_idx(other.tag_first_idx());
        }
    }
    /// Index of a node.
    #[repr(transparent)]
    #[derive(Clone)]
    pub struct NodeIndex {
        data: [u8; 5],
    }

    impl NodeIndex {
        /// Unsafe since the struct might not be self-contained
        pub unsafe fn new_unchecked() -> Self {
            Self { data: [0; 5] }
        }
    }

    impl flatdata::Struct for NodeIndex {
        unsafe fn create_unchecked() -> Self {
            Self { data: [0; 5] }
        }

        const SCHEMA: &'static str = schema::structs::NODE_INDEX;
        const SIZE_IN_BYTES: usize = 5;
        const IS_OVERLAPPING_WITH_NEXT: bool = false;
    }

    impl NodeIndex {
        pub fn new() -> Self {
            Self { data: [0; 5] }
        }

        /// Create reference from byte array of matching size
        pub fn from_bytes(data: &[u8; 5]) -> &Self {
            // Safety: This is safe since NodeIndex is repr(transparent)
            unsafe { std::mem::transmute(data) }
        }

        /// Create reference from byte array of matching size
        pub fn from_bytes_mut(data: &mut [u8; 5]) -> &mut Self {
            // Safety: This is safe since NodeIndex is repr(transparent)
            unsafe { std::mem::transmute(data) }
        }

        /// Create reference from byte array
        pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
            // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
            if data.len() < 5 {
                assert_eq!(data.len(), 5);
                return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
            }
            let ptr = data.as_ptr() as *const [u8; 5];
            // Safety: We checked length before
            Ok(Self::from_bytes(unsafe { &*ptr }))
        }

        /// Create reference from byte array
        pub fn from_bytes_slice_mut(
            data: &mut [u8],
        ) -> Result<&mut Self, flatdata::ResourceStorageError> {
            // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
            if data.len() < 5 {
                assert_eq!(data.len(), 5);
                return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
            }
            let ptr = data.as_ptr() as *mut [u8; 5];
            // Safety: We checked length before
            Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
        }

        pub fn as_bytes(&self) -> &[u8; 5] {
            &self.data
        }
    }

    impl Default for NodeIndex {
        fn default() -> Self {
            Self::new()
        }
    }

    impl flatdata::NoOverlap for NodeIndex {}

    impl NodeIndex {
        /// Index in the `nodes` vector.
        #[inline]
        pub fn value(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }
    }

    impl std::fmt::Debug for NodeIndex {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("NodeIndex")
                .field("value", &self.value())
                .finish()
        }
    }

    impl std::cmp::PartialEq for NodeIndex {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.value() == other.value()
        }
    }

    impl NodeIndex {
        /// Index in the `nodes` vector.
        #[inline]
        #[allow(missing_docs)]
        pub fn set_value(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 0, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &NodeIndex) {
            self.set_value(other.value());
        }
    }
    /// A way is an ordered list of nodes.
    ///
    /// See https://wiki.openstreetmap.org/wiki/Way.
    #[repr(transparent)]
    pub struct Way {
        data: [u8; 15],
    }

    impl Way {
        /// Unsafe since the struct might not be self-contained
        pub unsafe fn new_unchecked() -> Self {
            Self { data: [0; 15] }
        }
    }

    impl flatdata::Struct for Way {
        unsafe fn create_unchecked() -> Self {
            Self { data: [0; 15] }
        }

        const SCHEMA: &'static str = schema::structs::WAY;
        const SIZE_IN_BYTES: usize = 15;
        const IS_OVERLAPPING_WITH_NEXT: bool = true;
    }

    impl Way {
        /// Unique ID of the way.
        #[inline]
        pub fn id(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 0, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// First element of the range [`tags`].
        ///
        /// [`tags`]: #method.tags
        #[inline]
        pub fn tag_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Range of tags attached to this node.
        ///
        /// The values of the range are indexes in the `tags_index` vector.
        #[inline]
        pub fn tags(&self) -> std::ops::Range<u64> {
            let start = flatdata_read_bytes!(u64, self.data.as_ptr(), 40, 40);
            let end = flatdata_read_bytes!(u64, self.data.as_ptr(), 40 + 15 * 8, 40);
            start..end
        }

        /// First element of the range [`refs`].
        ///
        /// [`refs`]: #method.refs
        #[inline]
        pub fn ref_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 80, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Range of nodes this way consists of.
        ///
        /// The values of the range are indexes in the `nodes_index` vector.
        #[inline]
        pub fn refs(&self) -> std::ops::Range<u64> {
            let start = flatdata_read_bytes!(u64, self.data.as_ptr(), 80, 40);
            let end = flatdata_read_bytes!(u64, self.data.as_ptr(), 80 + 15 * 8, 40);
            start..end
        }
    }

    impl std::fmt::Debug for Way {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("Way")
                .field("id", &self.id())
                .field("tag_first_idx", &self.tag_first_idx())
                .field("ref_first_idx", &self.ref_first_idx())
                .finish()
        }
    }

    impl std::cmp::PartialEq for Way {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.id() == other.id()
                && self.tag_first_idx() == other.tag_first_idx()
                && self.ref_first_idx() == other.ref_first_idx()
        }
    }

    impl Way {
        /// Unique ID of the way.
        #[inline]
        #[allow(missing_docs)]
        pub fn set_id(&mut self, value: i64) {
            flatdata_write_bytes!(i64; value, self.data, 0, 40)
        }

        /// First element of the range [`tags`].
        ///
        /// [`tags`]: struct.WayRef.html#method.tags
        #[inline]
        #[allow(missing_docs)]
        pub fn set_tag_first_idx(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 40, 40)
        }

        /// First element of the range [`refs`].
        ///
        /// [`refs`]: struct.WayRef.html#method.refs
        #[inline]
        #[allow(missing_docs)]
        pub fn set_ref_first_idx(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 80, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &Way) {
            self.set_id(other.id());
            self.set_tag_first_idx(other.tag_first_idx());
            self.set_ref_first_idx(other.ref_first_idx());
        }
    }
    /// Index of a tag.
    #[repr(transparent)]
    #[derive(Clone)]
    pub struct TagIndex {
        data: [u8; 5],
    }

    impl TagIndex {
        /// Unsafe since the struct might not be self-contained
        pub unsafe fn new_unchecked() -> Self {
            Self { data: [0; 5] }
        }
    }

    impl flatdata::Struct for TagIndex {
        unsafe fn create_unchecked() -> Self {
            Self { data: [0; 5] }
        }

        const SCHEMA: &'static str = schema::structs::TAG_INDEX;
        const SIZE_IN_BYTES: usize = 5;
        const IS_OVERLAPPING_WITH_NEXT: bool = false;
    }

    impl TagIndex {
        pub fn new() -> Self {
            Self { data: [0; 5] }
        }

        /// Create reference from byte array of matching size
        pub fn from_bytes(data: &[u8; 5]) -> &Self {
            // Safety: This is safe since TagIndex is repr(transparent)
            unsafe { std::mem::transmute(data) }
        }

        /// Create reference from byte array of matching size
        pub fn from_bytes_mut(data: &mut [u8; 5]) -> &mut Self {
            // Safety: This is safe since TagIndex is repr(transparent)
            unsafe { std::mem::transmute(data) }
        }

        /// Create reference from byte array
        pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
            // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
            if data.len() < 5 {
                assert_eq!(data.len(), 5);
                return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
            }
            let ptr = data.as_ptr() as *const [u8; 5];
            // Safety: We checked length before
            Ok(Self::from_bytes(unsafe { &*ptr }))
        }

        /// Create reference from byte array
        pub fn from_bytes_slice_mut(
            data: &mut [u8],
        ) -> Result<&mut Self, flatdata::ResourceStorageError> {
            // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
            if data.len() < 5 {
                assert_eq!(data.len(), 5);
                return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
            }
            let ptr = data.as_ptr() as *mut [u8; 5];
            // Safety: We checked length before
            Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
        }

        pub fn as_bytes(&self) -> &[u8; 5] {
            &self.data
        }
    }

    impl Default for TagIndex {
        fn default() -> Self {
            Self::new()
        }
    }

    impl flatdata::NoOverlap for TagIndex {}

    impl TagIndex {
        /// Index in the `tags` vector.
        #[inline]
        pub fn value(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }
    }

    impl std::fmt::Debug for TagIndex {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("TagIndex")
                .field("value", &self.value())
                .finish()
        }
    }

    impl std::cmp::PartialEq for TagIndex {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.value() == other.value()
        }
    }

    impl TagIndex {
        /// Index in the `tags` vector.
        #[inline]
        #[allow(missing_docs)]
        pub fn set_value(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 0, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &TagIndex) {
            self.set_value(other.value());
        }
    }
    /// Node member of a relation.
    #[repr(transparent)]
    #[derive(Clone)]
    pub struct NodeMember {
        data: [u8; 10],
    }

    impl NodeMember {
        /// Unsafe since the struct might not be self-contained
        pub unsafe fn new_unchecked() -> Self {
            Self { data: [0; 10] }
        }
    }

    impl flatdata::Struct for NodeMember {
        unsafe fn create_unchecked() -> Self {
            Self { data: [0; 10] }
        }

        const SCHEMA: &'static str = schema::structs::NODE_MEMBER;
        const SIZE_IN_BYTES: usize = 10;
        const IS_OVERLAPPING_WITH_NEXT: bool = false;
    }

    impl NodeMember {
        pub fn new() -> Self {
            Self { data: [0; 10] }
        }

        /// Create reference from byte array of matching size
        pub fn from_bytes(data: &[u8; 10]) -> &Self {
            // Safety: This is safe since NodeMember is repr(transparent)
            unsafe { std::mem::transmute(data) }
        }

        /// Create reference from byte array of matching size
        pub fn from_bytes_mut(data: &mut [u8; 10]) -> &mut Self {
            // Safety: This is safe since NodeMember is repr(transparent)
            unsafe { std::mem::transmute(data) }
        }

        /// Create reference from byte array
        pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
            // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
            if data.len() < 10 {
                assert_eq!(data.len(), 10);
                return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
            }
            let ptr = data.as_ptr() as *const [u8; 10];
            // Safety: We checked length before
            Ok(Self::from_bytes(unsafe { &*ptr }))
        }

        /// Create reference from byte array
        pub fn from_bytes_slice_mut(
            data: &mut [u8],
        ) -> Result<&mut Self, flatdata::ResourceStorageError> {
            // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
            if data.len() < 10 {
                assert_eq!(data.len(), 10);
                return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
            }
            let ptr = data.as_ptr() as *mut [u8; 10];
            // Safety: We checked length before
            Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
        }

        pub fn as_bytes(&self) -> &[u8; 10] {
            &self.data
        }
    }

    impl Default for NodeMember {
        fn default() -> Self {
            Self::new()
        }
    }

    impl flatdata::NoOverlap for NodeMember {}

    impl NodeMember {
        /// Index of the node in the `nodes` vector.
        #[inline]
        pub fn node_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Optional textual field describing the function of the node in the relation.
        ///
        /// Index in `stringtable`.
        #[inline]
        pub fn role_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }
    }

    impl std::fmt::Debug for NodeMember {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("NodeMember")
                .field("node_idx", &self.node_idx())
                .field("role_idx", &self.role_idx())
                .finish()
        }
    }

    impl std::cmp::PartialEq for NodeMember {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.node_idx() == other.node_idx() && self.role_idx() == other.role_idx()
        }
    }

    impl NodeMember {
        /// Index of the node in the `nodes` vector.
        #[inline]
        #[allow(missing_docs)]
        pub fn set_node_idx(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 0, 40)
        }

        /// Optional textual field describing the function of the node in the relation.
        ///
        /// Index in `stringtable`.
        #[inline]
        #[allow(missing_docs)]
        pub fn set_role_idx(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 40, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &NodeMember) {
            self.set_node_idx(other.node_idx());
            self.set_role_idx(other.role_idx());
        }
    }
    /// Way member of a relation.
    #[repr(transparent)]
    #[derive(Clone)]
    pub struct WayMember {
        data: [u8; 10],
    }

    impl WayMember {
        /// Unsafe since the struct might not be self-contained
        pub unsafe fn new_unchecked() -> Self {
            Self { data: [0; 10] }
        }
    }

    impl flatdata::Struct for WayMember {
        unsafe fn create_unchecked() -> Self {
            Self { data: [0; 10] }
        }

        const SCHEMA: &'static str = schema::structs::WAY_MEMBER;
        const SIZE_IN_BYTES: usize = 10;
        const IS_OVERLAPPING_WITH_NEXT: bool = false;
    }

    impl WayMember {
        pub fn new() -> Self {
            Self { data: [0; 10] }
        }

        /// Create reference from byte array of matching size
        pub fn from_bytes(data: &[u8; 10]) -> &Self {
            // Safety: This is safe since WayMember is repr(transparent)
            unsafe { std::mem::transmute(data) }
        }

        /// Create reference from byte array of matching size
        pub fn from_bytes_mut(data: &mut [u8; 10]) -> &mut Self {
            // Safety: This is safe since WayMember is repr(transparent)
            unsafe { std::mem::transmute(data) }
        }

        /// Create reference from byte array
        pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
            // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
            if data.len() < 10 {
                assert_eq!(data.len(), 10);
                return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
            }
            let ptr = data.as_ptr() as *const [u8; 10];
            // Safety: We checked length before
            Ok(Self::from_bytes(unsafe { &*ptr }))
        }

        /// Create reference from byte array
        pub fn from_bytes_slice_mut(
            data: &mut [u8],
        ) -> Result<&mut Self, flatdata::ResourceStorageError> {
            // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
            if data.len() < 10 {
                assert_eq!(data.len(), 10);
                return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
            }
            let ptr = data.as_ptr() as *mut [u8; 10];
            // Safety: We checked length before
            Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
        }

        pub fn as_bytes(&self) -> &[u8; 10] {
            &self.data
        }
    }

    impl Default for WayMember {
        fn default() -> Self {
            Self::new()
        }
    }

    impl flatdata::NoOverlap for WayMember {}

    impl WayMember {
        /// Index of the way in the `ways` vector.
        #[inline]
        pub fn way_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Optional textual field describing the function of the way in the relation.
        ///
        /// Index in `stringtable`.
        #[inline]
        pub fn role_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }
    }

    impl std::fmt::Debug for WayMember {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("WayMember")
                .field("way_idx", &self.way_idx())
                .field("role_idx", &self.role_idx())
                .finish()
        }
    }

    impl std::cmp::PartialEq for WayMember {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.way_idx() == other.way_idx() && self.role_idx() == other.role_idx()
        }
    }

    impl WayMember {
        /// Index of the way in the `ways` vector.
        #[inline]
        #[allow(missing_docs)]
        pub fn set_way_idx(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 0, 40)
        }

        /// Optional textual field describing the function of the way in the relation.
        ///
        /// Index in `stringtable`.
        #[inline]
        #[allow(missing_docs)]
        pub fn set_role_idx(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 40, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &WayMember) {
            self.set_way_idx(other.way_idx());
            self.set_role_idx(other.role_idx());
        }
    }
    /// Relation member of a relation.
    #[repr(transparent)]
    #[derive(Clone)]
    pub struct RelationMember {
        data: [u8; 10],
    }

    impl RelationMember {
        /// Unsafe since the struct might not be self-contained
        pub unsafe fn new_unchecked() -> Self {
            Self { data: [0; 10] }
        }
    }

    impl flatdata::Struct for RelationMember {
        unsafe fn create_unchecked() -> Self {
            Self { data: [0; 10] }
        }

        const SCHEMA: &'static str = schema::structs::RELATION_MEMBER;
        const SIZE_IN_BYTES: usize = 10;
        const IS_OVERLAPPING_WITH_NEXT: bool = false;
    }

    impl RelationMember {
        pub fn new() -> Self {
            Self { data: [0; 10] }
        }

        /// Create reference from byte array of matching size
        pub fn from_bytes(data: &[u8; 10]) -> &Self {
            // Safety: This is safe since RelationMember is repr(transparent)
            unsafe { std::mem::transmute(data) }
        }

        /// Create reference from byte array of matching size
        pub fn from_bytes_mut(data: &mut [u8; 10]) -> &mut Self {
            // Safety: This is safe since RelationMember is repr(transparent)
            unsafe { std::mem::transmute(data) }
        }

        /// Create reference from byte array
        pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
            // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
            if data.len() < 10 {
                assert_eq!(data.len(), 10);
                return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
            }
            let ptr = data.as_ptr() as *const [u8; 10];
            // Safety: We checked length before
            Ok(Self::from_bytes(unsafe { &*ptr }))
        }

        /// Create reference from byte array
        pub fn from_bytes_slice_mut(
            data: &mut [u8],
        ) -> Result<&mut Self, flatdata::ResourceStorageError> {
            // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
            if data.len() < 10 {
                assert_eq!(data.len(), 10);
                return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
            }
            let ptr = data.as_ptr() as *mut [u8; 10];
            // Safety: We checked length before
            Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
        }

        pub fn as_bytes(&self) -> &[u8; 10] {
            &self.data
        }
    }

    impl Default for RelationMember {
        fn default() -> Self {
            Self::new()
        }
    }

    impl flatdata::NoOverlap for RelationMember {}

    impl RelationMember {
        /// Index of the relation in the `relations` vector.
        #[inline]
        pub fn relation_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Optional textual field describing the function of the relation in the parent relation.
        ///
        /// Index in `stringtable`.
        #[inline]
        pub fn role_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }
    }

    impl std::fmt::Debug for RelationMember {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("RelationMember")
                .field("relation_idx", &self.relation_idx())
                .field("role_idx", &self.role_idx())
                .finish()
        }
    }

    impl std::cmp::PartialEq for RelationMember {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.relation_idx() == other.relation_idx() && self.role_idx() == other.role_idx()
        }
    }

    impl RelationMember {
        /// Index of the relation in the `relations` vector.
        #[inline]
        #[allow(missing_docs)]
        pub fn set_relation_idx(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 0, 40)
        }

        /// Optional textual field describing the function of the relation in the parent relation.
        ///
        /// Index in `stringtable`.
        #[inline]
        #[allow(missing_docs)]
        pub fn set_role_idx(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 40, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &RelationMember) {
            self.set_relation_idx(other.relation_idx());
            self.set_role_idx(other.role_idx());
        }
    }
    /// A relation is an ordered list of one or more nodes, ways and/or relations as members.
    ///
    /// See https://wiki.openstreetmap.org/wiki/Relation.
    #[repr(transparent)]
    pub struct Relation {
        data: [u8; 10],
    }

    impl Relation {
        /// Unsafe since the struct might not be self-contained
        pub unsafe fn new_unchecked() -> Self {
            Self { data: [0; 10] }
        }
    }

    impl flatdata::Struct for Relation {
        unsafe fn create_unchecked() -> Self {
            Self { data: [0; 10] }
        }

        const SCHEMA: &'static str = schema::structs::RELATION;
        const SIZE_IN_BYTES: usize = 10;
        const IS_OVERLAPPING_WITH_NEXT: bool = true;
    }

    impl Relation {
        /// Unique ID of the relation.
        #[inline]
        pub fn id(&self) -> i64 {
            let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 0, 40);
            unsafe { std::mem::transmute::<i64, i64>(value) }
        }

        /// First element of the range [`tags`].
        ///
        /// [`tags`]: #method.tags
        #[inline]
        pub fn tag_first_idx(&self) -> u64 {
            let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 40, 40);
            unsafe { std::mem::transmute::<u64, u64>(value) }
        }

        /// Range of tags attached to this relation.
        ///
        /// The values of the range are indexes in the `tags` vector.
        #[inline]
        pub fn tags(&self) -> std::ops::Range<u64> {
            let start = flatdata_read_bytes!(u64, self.data.as_ptr(), 40, 40);
            let end = flatdata_read_bytes!(u64, self.data.as_ptr(), 40 + 10 * 8, 40);
            start..end
        }
    }

    impl std::fmt::Debug for Relation {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            f.debug_struct("Relation")
                .field("id", &self.id())
                .field("tag_first_idx", &self.tag_first_idx())
                .finish()
        }
    }

    impl std::cmp::PartialEq for Relation {
        #[inline]
        fn eq(&self, other: &Self) -> bool {
            self.id() == other.id() && self.tag_first_idx() == other.tag_first_idx()
        }
    }

    impl Relation {
        /// Unique ID of the relation.
        #[inline]
        #[allow(missing_docs)]
        pub fn set_id(&mut self, value: i64) {
            flatdata_write_bytes!(i64; value, self.data, 0, 40)
        }

        /// First element of the range [`tags`].
        ///
        /// [`tags`]: struct.RelationRef.html#method.tags
        #[inline]
        #[allow(missing_docs)]
        pub fn set_tag_first_idx(&mut self, value: u64) {
            flatdata_write_bytes!(u64; value, self.data, 40, 40)
        }

        /// Copies the data from `other` into this struct.
        #[inline]
        pub fn fill_from(&mut self, other: &Relation) {
            self.set_id(other.id());
            self.set_tag_first_idx(other.tag_first_idx());
        }
    }

    /// Enum for read-only heterogeneous access to elements in a
    /// bucket of the [`relation_members`] resource.
    ///
    /// [`relation_members`]: struct.Archive{.osm.Osm}.html#method.relation_members
    #[derive(Clone, PartialEq)]
    pub enum RelationMembersRef<'a> {
        #[allow(missing_docs)]
        NodeMember(&'a super::osm::NodeMember),
        #[allow(missing_docs)]
        WayMember(&'a super::osm::WayMember),
        #[allow(missing_docs)]
        RelationMember(&'a super::osm::RelationMember),
    }

    impl<'a> ::std::fmt::Debug for RelationMembersRef<'a> {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            match *self {
                RelationMembersRef::NodeMember(ref inner) => write!(f, "{:?}", inner),
                RelationMembersRef::WayMember(ref inner) => write!(f, "{:?}", inner),
                RelationMembersRef::RelationMember(ref inner) => write!(f, "{:?}", inner),
            }
        }
    }

    impl<'a> flatdata::VariadicRef for RelationMembersRef<'a> {
        #[inline]
        fn size_in_bytes(&self) -> usize {
            match *self {
                RelationMembersRef::NodeMember(_) => {
                    <super::osm::NodeMember as flatdata::Struct>::SIZE_IN_BYTES
                }
                RelationMembersRef::WayMember(_) => {
                    <super::osm::WayMember as flatdata::Struct>::SIZE_IN_BYTES
                }
                RelationMembersRef::RelationMember(_) => {
                    <super::osm::RelationMember as flatdata::Struct>::SIZE_IN_BYTES
                }
            }
        }
    }

    /// Builder of buckets in the [`relation_members`] resource.
    ///
    /// Refers to a single bucket in the [`relation_members`] multivector and
    /// provides methods for adding heterogeneous data to the bucket.
    ///
    /// [`relation_members`]: struct.Archive{.osm.Osm}.html#method.relation_members
    pub struct RelationMembersBuilder<'a> {
        data: &'a mut Vec<u8>,
    }

    impl<'a> RelationMembersBuilder<'a> {
        /// Adds data of the type [`NodeMember`] to the bucket.
        ///
        /// [`NodeMember`]: struct.NodeMember.html
        #[inline]
        pub fn add_node_member<'b>(&'b mut self) -> &'b mut super::osm::NodeMember {
            let old_len = self.data.len();
            let increment = 1 + <super::osm::NodeMember as flatdata::Struct>::SIZE_IN_BYTES;
            self.data.resize(old_len + increment, 0);
            self.data[old_len] = 0;
            let slice = &mut self.data[1 + old_len..];
            super::osm::NodeMember::from_bytes_slice_mut(slice)
                .expect("Logic error: Cannot create super::osm::NodeMember from slice")
        }
        /// Adds data of the type [`WayMember`] to the bucket.
        ///
        /// [`WayMember`]: struct.WayMember.html
        #[inline]
        pub fn add_way_member<'b>(&'b mut self) -> &'b mut super::osm::WayMember {
            let old_len = self.data.len();
            let increment = 1 + <super::osm::WayMember as flatdata::Struct>::SIZE_IN_BYTES;
            self.data.resize(old_len + increment, 0);
            self.data[old_len] = 1;
            let slice = &mut self.data[1 + old_len..];
            super::osm::WayMember::from_bytes_slice_mut(slice)
                .expect("Logic error: Cannot create super::osm::WayMember from slice")
        }
        /// Adds data of the type [`RelationMember`] to the bucket.
        ///
        /// [`RelationMember`]: struct.RelationMember.html
        #[inline]
        pub fn add_relation_member<'b>(&'b mut self) -> &'b mut super::osm::RelationMember {
            let old_len = self.data.len();
            let increment = 1 + <super::osm::RelationMember as flatdata::Struct>::SIZE_IN_BYTES;
            self.data.resize(old_len + increment, 0);
            self.data[old_len] = 2;
            let slice = &mut self.data[1 + old_len..];
            super::osm::RelationMember::from_bytes_slice_mut(slice)
                .expect("Logic error: Cannot create super::osm::RelationMember from slice")
        }
    }

    /// Variadic struct attached to the [`relation_members`] archive resource.
    ///
    /// It unifies the following data types:
    //
    /// * [`NodeMember`]
    /// * [`WayMember`]
    /// * [`RelationMember`]
    ///
    /// ## Access pattern
    ///
    /// This structure is used as a template parameter in [`relation_members`] multivector/
    /// multiarray view. It does not contain any data, instead it references
    ///
    /// * [`RelationMembersRef`] for the read-only heterogeneous access, and
    /// * [`RelationMembersBuilder`] for the mutable builder pattern access.
    ///
    /// [`relation_members`]: struct.Archive{.osm.Osm}.html#method.relation_members
    /// [`RelationMembersRef`]: enum.RelationMembersRef.html
    /// [`RelationMembersBuilder`]: struct.RelationMembersBuilder.html
    /// [`NodeMember`]: struct.NodeMember.html
    /// [`WayMember`]: struct.WayMember.html
    /// [`RelationMember`]: struct.RelationMember.html
    #[derive(Clone)]
    pub struct RelationMembers {}

    impl flatdata::VariadicIndex for RelationMembers {
        type Index = super::_builtin::multivector::IndexType40;
    }

    impl<'a> flatdata::VariadicStruct<'a> for RelationMembers {
        type Item = RelationMembersRef<'a>;

        #[inline]
        fn create(index: flatdata::TypeIndex, data: &'a [u8]) -> Self::Item {
            match index {
                0 => RelationMembersRef::NodeMember(
                    super::osm::NodeMember::from_bytes_slice(&data).expect("Corrupted data"),
                ),
                1 => RelationMembersRef::WayMember(
                    super::osm::WayMember::from_bytes_slice(&data).expect("Corrupted data"),
                ),
                2 => RelationMembersRef::RelationMember(
                    super::osm::RelationMember::from_bytes_slice(&data).expect("Corrupted data"),
                ),
                _ => panic!(
                    "invalid type index {} for variadic type RelationMembersRef",
                    index
                ),
            }
        }

        type ItemMut = RelationMembersBuilder<'a>;

        #[inline]
        fn create_mut(data: &'a mut Vec<u8>) -> Self::ItemMut {
            Self::ItemMut { data }
        }
    }

    /// OSM data archive
    ///
    /// Relations and relation members are indexed with the same index, i.e.
    /// a relation at index `i` in the vector `relations` has the members
    /// at index `i` in the multivector `relation_members`.
    ///
    /// All 1:n relationships are modeled in-place by using an additional index. This is a
    /// common pattern in flatdata. For example, a node might have multiple tags attached
    /// to it. To model this, a node in `nodes` references the first tag attached to it
    /// by storing an index in the `tags_index` vector. The next node in `nodes` again
    /// references its first tag, which is the last tag (exclusive) of the previous node.
    ///
    /// ```text
    /// nodes:      [ ..., n_1, n_2, ... ]
    ///                     |    |
    ///                     |    +-------+
    ///                     v            v
    /// tags_index: [ ..., t_11, t_12, ..., t_1n, t_21, ... t_2m, ... ]
    /// ```
    #[derive(Clone)]
    pub struct Osm {
        _storage: ::std::rc::Rc<dyn flatdata::ResourceStorage>,
        header: &'static super::osm::Header,
        nodes: &'static [super::osm::Node],
        ways: &'static [super::osm::Way],
        relations: &'static [super::osm::Relation],
        relation_members: flatdata::MultiArrayView<'static, RelationMembers>,
        tags: &'static [super::osm::Tag],
        tags_index: &'static [super::osm::TagIndex],
        nodes_index: &'static [super::osm::NodeIndex],
        stringtable: flatdata::RawData<'static>,
    }

    impl Osm {
        fn signature_name(archive_name: &str) -> String {
            format!("{}.archive", archive_name)
        }

        /// Header which contains the metadata attached to the archive.
        #[inline]
        pub fn header(&self) -> &super::osm::Header {
            self.header
        }

        /// List of nodes.
        ///
        /// A node references a range of tags in the `tags_index` vector.
        #[inline]
        pub fn nodes(&self) -> &[super::osm::Node] {
            self.nodes
        }

        /// List of ways.
        ///
        /// A way references
        ///
        /// * a range of tags in the `tags_index` vector, and
        /// * a range of nodes in the `nodes_index` vector.
        #[inline]
        pub fn ways(&self) -> &[super::osm::Way] {
            self.ways
        }

        /// List of relations.
        ///
        /// A relation references a range of tags in `tags_index` vectors.
        /// Members are attached to a relation implicitly: members that belong to a
        /// relation at index `i` are at index `i` in the `relation_members` multivector.
        #[inline]
        pub fn relations(&self) -> &[super::osm::Relation] {
            self.relations
        }

        /// Members attached to relations.
        ///
        /// An index in this multivector corresponds to an index in the `relations` vector.
        ///
        /// A member has a variadic type: `NodeMember`, `WayMember` or `RelationMember`.
        /// Each type references its role in the `stringtable` raw data. Additionally,
        ///
        /// * a node member references a node in the `nodes` vector,
        /// * a way member references a way in the `ways` vector,
        /// * a relation member references a relation in the `relations` vector.
        #[inline]
        pub fn relation_members(&self) -> &flatdata::MultiArrayView<RelationMembers> {
            &self.relation_members
        }

        /// List of tags.
        ///
        /// A tag references its key and value in the `stringtable` raw data.
        #[inline]
        pub fn tags(&self) -> &[super::osm::Tag] {
            self.tags
        }

        /// Auxiliary index of tags to model 1:n relationships between nodes, ways, relations
        /// and tags.
        #[inline]
        pub fn tags_index(&self) -> &[super::osm::TagIndex] {
            self.tags_index
        }

        /// Auxiliary index of nodes to model 1:n relationship between ways and nodes.
        #[inline]
        pub fn nodes_index(&self) -> &[super::osm::NodeIndex] {
            self.nodes_index
        }

        /// List of strings separated by `\0`.
        #[inline]
        pub fn stringtable(&self) -> flatdata::RawData {
            self.stringtable
        }
    }

    impl ::std::fmt::Debug for Osm {
        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
            f.debug_struct("Osm")
                .field("header", &self.header())
                .field("nodes", &self.nodes())
                .field("ways", &self.ways())
                .field("relations", &self.relations())
                .field("relation_members", &self.relation_members())
                .field("tags", &self.tags())
                .field("tags_index", &self.tags_index())
                .field("nodes_index", &self.nodes_index())
                .field("stringtable", &self.stringtable())
                .finish()
        }
    }

    impl flatdata::Archive for Osm {
        const NAME: &'static str = "Osm";
        const SCHEMA: &'static str = schema::osm::OSM;

        fn open(
            storage: ::std::rc::Rc<dyn flatdata::ResourceStorage>,
        ) -> ::std::result::Result<Self, flatdata::ResourceStorageError> {
            #[allow(unused_imports)]
            use flatdata::SliceExt;
            // extend lifetime since Rust cannot know that we reference a cache here
            #[allow(unused_variables)]
        let extend = |x : Result<&[u8], flatdata::ResourceStorageError>| -> Result<&'static [u8], flatdata::ResourceStorageError> {x.map(|x| unsafe{std::mem::transmute(x)})};

            storage.read(&Self::signature_name(Self::NAME), Self::SCHEMA)?;

            let resource = extend(storage.read("header", schema::osm::resources::HEADER));
            let header = resource.map(|x| super::osm::Header::from_bytes_slice(x))??;
            let resource = extend(storage.read("nodes", schema::osm::resources::NODES));
            let nodes = resource.map(|x| <&[super::osm::Node]>::from_bytes(x))??;
            let resource = extend(storage.read("ways", schema::osm::resources::WAYS));
            let ways = resource.map(|x| <&[super::osm::Way]>::from_bytes(x))??;
            let resource = extend(storage.read("relations", schema::osm::resources::RELATIONS));
            let relations = resource.map(|x| <&[super::osm::Relation]>::from_bytes(x))??;
            let relation_members = {
                let index_schema = &format!("index({})", schema::osm::resources::RELATION_MEMBERS);
                let index = extend(storage.read("relation_members_index", &index_schema));
                let data = extend(
                    storage.read("relation_members", schema::osm::resources::RELATION_MEMBERS),
                );
                let result = match (index, data) {
                    (Ok(index), Ok(data)) => Ok(flatdata::MultiArrayView::new(
                        <&[super::_builtin::multivector::IndexType40]>::from_bytes(index)?,
                        data,
                    )),
                    (Ok(_), Err(x)) | (Err(x), Ok(_)) => {
                        return Err(x);
                    }
                    (Err(x), Err(_)) => Err(x),
                };
                result?
            };
            let resource = extend(storage.read("tags", schema::osm::resources::TAGS));
            let tags = resource.map(|x| <&[super::osm::Tag]>::from_bytes(x))??;
            let resource = extend(storage.read("tags_index", schema::osm::resources::TAGS_INDEX));
            let tags_index = resource.map(|x| <&[super::osm::TagIndex]>::from_bytes(x))??;
            let resource = extend(storage.read("nodes_index", schema::osm::resources::NODES_INDEX));
            let nodes_index = resource.map(|x| <&[super::osm::NodeIndex]>::from_bytes(x))??;
            let resource = extend(storage.read("stringtable", schema::osm::resources::STRINGTABLE));
            let stringtable = resource.map(|x| flatdata::RawData::new(x))?;

            Ok(Self {
                _storage: storage,
                header,
                nodes,
                ways,
                relations,
                relation_members,
                tags,
                tags_index,
                nodes_index,
                stringtable,
            })
        }
    }

    /// Builder for creating [`Osm`] archives.
    ///
    ///[`Osm`]: struct.Osm.html
    #[derive(Clone, Debug)]
    pub struct OsmBuilder {
        storage: ::std::rc::Rc<dyn flatdata::ResourceStorage>,
    }

    impl OsmBuilder {
        #[inline]
        /// Stores [`header`] in the archive.
        ///
        /// [`header`]: struct.Osm.html#method.header
        /// Stores [`header`] in the archive.
        pub fn set_header(&self, resource: &super::osm::Header) -> ::std::io::Result<()> {
            let data = resource.as_bytes();
            self.storage
                .write("header", schema::osm::resources::HEADER, data)
        }

        #[inline]
        /// Stores [`nodes`] in the archive.
        ///
        /// [`nodes`]: struct.Osm.html#method.nodes
        pub fn set_nodes(&self, vector: &[super::osm::Node]) -> ::std::io::Result<()> {
            use flatdata::SliceExt;
            self.storage
                .write("nodes", schema::osm::resources::NODES, vector.as_bytes())
        }

        /// Opens [`nodes`] in the archive for buffered writing.
        ///
        /// Elements can be added to the vector until the [`ExternalVector::close`] method
        /// is called. To flush the data fully into the archive, this method must be called
        /// in the end.
        ///
        /// [`nodes`]: struct.Osm.html#method.nodes
        /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
        #[inline]
        pub fn start_nodes(&self) -> ::std::io::Result<flatdata::ExternalVector<super::osm::Node>> {
            flatdata::create_external_vector(&*self.storage, "nodes", schema::osm::resources::NODES)
        }

        #[inline]
        /// Stores [`ways`] in the archive.
        ///
        /// [`ways`]: struct.Osm.html#method.ways
        pub fn set_ways(&self, vector: &[super::osm::Way]) -> ::std::io::Result<()> {
            use flatdata::SliceExt;
            self.storage
                .write("ways", schema::osm::resources::WAYS, vector.as_bytes())
        }

        /// Opens [`ways`] in the archive for buffered writing.
        ///
        /// Elements can be added to the vector until the [`ExternalVector::close`] method
        /// is called. To flush the data fully into the archive, this method must be called
        /// in the end.
        ///
        /// [`ways`]: struct.Osm.html#method.ways
        /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
        #[inline]
        pub fn start_ways(&self) -> ::std::io::Result<flatdata::ExternalVector<super::osm::Way>> {
            flatdata::create_external_vector(&*self.storage, "ways", schema::osm::resources::WAYS)
        }

        #[inline]
        /// Stores [`relations`] in the archive.
        ///
        /// [`relations`]: struct.Osm.html#method.relations
        pub fn set_relations(&self, vector: &[super::osm::Relation]) -> ::std::io::Result<()> {
            use flatdata::SliceExt;
            self.storage.write(
                "relations",
                schema::osm::resources::RELATIONS,
                vector.as_bytes(),
            )
        }

        /// Opens [`relations`] in the archive for buffered writing.
        ///
        /// Elements can be added to the vector until the [`ExternalVector::close`] method
        /// is called. To flush the data fully into the archive, this method must be called
        /// in the end.
        ///
        /// [`relations`]: struct.Osm.html#method.relations
        /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
        #[inline]
        pub fn start_relations(
            &self,
        ) -> ::std::io::Result<flatdata::ExternalVector<super::osm::Relation>> {
            flatdata::create_external_vector(
                &*self.storage,
                "relations",
                schema::osm::resources::RELATIONS,
            )
        }

        /// Opens [`relation_members`] in the archive for buffered writing.
        ///
        /// Elements can be added to the multivector until the [`MultiVector::close`] method
        /// is called. To flush the data fully into the archive, this method must be called
        /// in the end.
        ///
        /// [`relation_members`]: struct.Osm.html#method.relation_members
        /// [`MultiVector::close`]: flatdata/struct.MultiVector.html#method.close
        #[inline]
        pub fn start_relation_members(
            &self,
        ) -> ::std::io::Result<flatdata::MultiVector<RelationMembers>> {
            flatdata::create_multi_vector(
                &*self.storage,
                "relation_members",
                schema::osm::resources::RELATION_MEMBERS,
            )
        }

        #[inline]
        /// Stores [`tags`] in the archive.
        ///
        /// [`tags`]: struct.Osm.html#method.tags
        pub fn set_tags(&self, vector: &[super::osm::Tag]) -> ::std::io::Result<()> {
            use flatdata::SliceExt;
            self.storage
                .write("tags", schema::osm::resources::TAGS, vector.as_bytes())
        }

        /// Opens [`tags`] in the archive for buffered writing.
        ///
        /// Elements can be added to the vector until the [`ExternalVector::close`] method
        /// is called. To flush the data fully into the archive, this method must be called
        /// in the end.
        ///
        /// [`tags`]: struct.Osm.html#method.tags
        /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
        #[inline]
        pub fn start_tags(&self) -> ::std::io::Result<flatdata::ExternalVector<super::osm::Tag>> {
            flatdata::create_external_vector(&*self.storage, "tags", schema::osm::resources::TAGS)
        }

        #[inline]
        /// Stores [`tags_index`] in the archive.
        ///
        /// [`tags_index`]: struct.Osm.html#method.tags_index
        pub fn set_tags_index(&self, vector: &[super::osm::TagIndex]) -> ::std::io::Result<()> {
            use flatdata::SliceExt;
            self.storage.write(
                "tags_index",
                schema::osm::resources::TAGS_INDEX,
                vector.as_bytes(),
            )
        }

        /// Opens [`tags_index`] in the archive for buffered writing.
        ///
        /// Elements can be added to the vector until the [`ExternalVector::close`] method
        /// is called. To flush the data fully into the archive, this method must be called
        /// in the end.
        ///
        /// [`tags_index`]: struct.Osm.html#method.tags_index
        /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
        #[inline]
        pub fn start_tags_index(
            &self,
        ) -> ::std::io::Result<flatdata::ExternalVector<super::osm::TagIndex>> {
            flatdata::create_external_vector(
                &*self.storage,
                "tags_index",
                schema::osm::resources::TAGS_INDEX,
            )
        }

        #[inline]
        /// Stores [`nodes_index`] in the archive.
        ///
        /// [`nodes_index`]: struct.Osm.html#method.nodes_index
        pub fn set_nodes_index(&self, vector: &[super::osm::NodeIndex]) -> ::std::io::Result<()> {
            use flatdata::SliceExt;
            self.storage.write(
                "nodes_index",
                schema::osm::resources::NODES_INDEX,
                vector.as_bytes(),
            )
        }

        /// Opens [`nodes_index`] in the archive for buffered writing.
        ///
        /// Elements can be added to the vector until the [`ExternalVector::close`] method
        /// is called. To flush the data fully into the archive, this method must be called
        /// in the end.
        ///
        /// [`nodes_index`]: struct.Osm.html#method.nodes_index
        /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
        #[inline]
        pub fn start_nodes_index(
            &self,
        ) -> ::std::io::Result<flatdata::ExternalVector<super::osm::NodeIndex>> {
            flatdata::create_external_vector(
                &*self.storage,
                "nodes_index",
                schema::osm::resources::NODES_INDEX,
            )
        }

        /// Stores [`stringtable`] in the archive.
        ///
        /// [`stringtable`]: struct.Osm.html#method.stringtable
        #[inline]
        pub fn set_stringtable(&self, data: &[u8]) -> ::std::io::Result<()> {
            self.storage
                .write("stringtable", schema::osm::resources::STRINGTABLE, data)
        }
    }

    impl flatdata::ArchiveBuilder for OsmBuilder {
        const NAME: &'static str = "Osm";
        const SCHEMA: &'static str = schema::osm::OSM;

        fn new(
            storage: ::std::rc::Rc<dyn flatdata::ResourceStorage>,
        ) -> Result<Self, flatdata::ResourceStorageError> {
            flatdata::create_archive::<Self>(&storage)?;
            Ok(Self { storage })
        }
    }
}

#[doc(hidden)]
pub mod _builtin {

    #[allow(missing_docs)]
    pub mod multivector {

        #[doc(hidden)]
        pub mod schema {
            pub mod structs {
                pub const INDEX_TYPE40: &str = r#""#;
            }
        }
        /// Builtin type to for MultiVector index
        #[repr(transparent)]
        pub struct IndexType40 {
            data: [u8; 5],
        }

        impl IndexType40 {
            /// Unsafe since the struct might not be self-contained
            pub unsafe fn new_unchecked() -> Self {
                Self { data: [0; 5] }
            }
        }

        impl flatdata::Struct for IndexType40 {
            unsafe fn create_unchecked() -> Self {
                Self { data: [0; 5] }
            }

            const SCHEMA: &'static str = schema::structs::INDEX_TYPE40;
            const SIZE_IN_BYTES: usize = 5;
            const IS_OVERLAPPING_WITH_NEXT: bool = true;
        }

        impl IndexType40 {
            /// First element of the range [`range`].
            ///
            /// [`range`]: #method.range
            #[inline]
            pub fn value(&self) -> u64 {
                let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 40);
                unsafe { std::mem::transmute::<u64, u64>(value) }
            }

            #[inline]
            pub fn range(&self) -> std::ops::Range<u64> {
                let start = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 40);
                let end = flatdata_read_bytes!(u64, self.data.as_ptr(), 0 + 5 * 8, 40);
                start..end
            }
        }

        impl std::fmt::Debug for IndexType40 {
            fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                f.debug_struct("IndexType40")
                    .field("value", &self.value())
                    .finish()
            }
        }

        impl std::cmp::PartialEq for IndexType40 {
            #[inline]
            fn eq(&self, other: &Self) -> bool {
                self.value() == other.value()
            }
        }

        impl IndexType40 {
            /// First element of the range [`range`].
            ///
            /// [`range`]: struct.IndexType40Ref.html#method.range
            #[inline]
            #[allow(missing_docs)]
            pub fn set_value(&mut self, value: u64) {
                flatdata_write_bytes!(u64; value, self.data, 0, 40)
            }

            /// Copies the data from `other` into this struct.
            #[inline]
            pub fn fill_from(&mut self, other: &IndexType40) {
                self.set_value(other.value());
            }
        }

        impl flatdata::IndexStruct for IndexType40 {
            #[inline]
            fn range(&self) -> std::ops::Range<usize> {
                let range = self.range();
                range.start as usize..range.end as usize
            }

            #[inline]
            fn set_index(&mut self, value: usize) {
                self.set_value(value as u64);
            }
        }
    }

    #[doc(hidden)]
    pub mod schema {
        pub mod structs {}
    }
}
