// Do not edit: This code was generated by flatdata's generator.
#[allow(missing_docs)]
pub mod osm {

    /// Special value which represents an invalid index.
pub const INVALID_IDX: u64 = 1_099_511_627_775;

    /// All coordinate are scaled by this constant to convert them to integers.
pub const COORD_SCALE: u64 = 1_000_000_000;
/// Metadata attached to the archive.
#[repr(transparent)]
#[derive(Clone)]
pub struct Header {
    data: [u8; 62],
}

impl Header {
    /// Unsafe since the struct might not be self-contained
    pub unsafe fn new_unchecked( ) -> Self {
        Self{data : [0; 62]}
    }
}

impl flatdata::Struct for Header {
    unsafe fn create_unchecked( ) -> Self {
        Self{data : [0; 62]}
    }

    const SIZE_IN_BYTES: usize = 62;
    const IS_OVERLAPPING_WITH_NEXT : bool = false;
}

impl Header {
    pub fn new( ) -> Self {
        Self{data : [0; 62]}
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes(data: &[u8; 62]) -> &Self {
        // Safety: This is safe since Header is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes_mut(data: &mut [u8; 62]) -> &mut Self {
        // Safety: This is safe since Header is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array
    pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 62 {
            assert_eq!(data.len(), 62);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *const [u8; 62];
        // Safety: We checked length before
        Ok(Self::from_bytes(unsafe { &*ptr }))
    }

    /// Create reference from byte array
    pub fn from_bytes_slice_mut(data: &mut [u8]) -> Result<&mut Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 62 {
            assert_eq!(data.len(), 62);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *mut [u8; 62];
        // Safety: We checked length before
        Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
    }

    pub fn as_bytes(&self) -> &[u8; 62] {
        &self.data
    }
}

impl Default for Header {
    fn default( ) -> Self {
        Self::new( )
    }
}

unsafe impl flatdata::NoOverlap for Header {}

impl Header {
    /// Bounding box (min longitude scaled with `COORD_SCALE`)
    #[inline]
    pub fn bbox_left(&self) -> i64 {
        let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 0, 40);
        unsafe { std::mem::transmute::<i64, i64>(value) }
    }

    /// Bounding box (max longitude scaled with `COORD_SCALE`)
    #[inline]
    pub fn bbox_right(&self) -> i64 {
        let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 40, 40);
        unsafe { std::mem::transmute::<i64, i64>(value) }
    }

    /// Bounding box (max latitude scaled with `COORD_SCALE`)
    #[inline]
    pub fn bbox_top(&self) -> i64 {
        let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 80, 40);
        unsafe { std::mem::transmute::<i64, i64>(value) }
    }

    /// Bounding box (min latitude scaled with `COORD_SCALE`)
    #[inline]
    pub fn bbox_bottom(&self) -> i64 {
        let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 120, 40);
        unsafe { std::mem::transmute::<i64, i64>(value) }
    }

    /// Reference to the first required feature in `stringtable`.
    #[inline]
    pub fn required_feature_first_idx(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 160, 40);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

    /// Number of required features.
    #[inline]
    pub fn required_features_size(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data.as_ptr(), 200, 4);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }

    /// Reference to the first optional feature in `stringtable`.
    #[inline]
    pub fn optional_feature_first_idx(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 204, 40);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

    /// Number of optional features.
    #[inline]
    pub fn optional_features_size(&self) -> u32 {
        let value = flatdata_read_bytes!(u32, self.data.as_ptr(), 244, 4);
        unsafe { std::mem::transmute::<u32, u32>(value) }
    }

    /// Writing program used to write the data (reference to `stringtable`).
    #[inline]
    pub fn writingprogram_idx(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 248, 40);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

    /// The origin (source) of the data.
    #[inline]
    pub fn source_idx(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 288, 40);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

    /// Replication timestamp, expressed in seconds since the epoch.
/// See [`state.txt`].
///
/// [`state.txt`]: https://wiki.openstreetmap.org/wiki/Planet.osm/diffs#Minute.2C_Hour.2C_and_Day_Files_Organisation
    #[inline]
    pub fn osmosis_replication_timestamp(&self) -> i64 {
        let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 328, 64);
        unsafe { std::mem::transmute::<i64, i64>(value) }
    }

    /// Replication sequence number (`sequenceNumber` from [`state.txt`]).
///
/// [`state.txt`]: https://wiki.openstreetmap.org/wiki/Planet.osm/diffs#Minute.2C_Hour.2C_and_Day_Files_Organisation
    #[inline]
    pub fn osmosis_replication_sequence_number(&self) -> i64 {
        let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 392, 64);
        unsafe { std::mem::transmute::<i64, i64>(value) }
    }

    /// Replication base URL (reference to `stringtable`).
    #[inline]
    pub fn osmosis_replication_base_url_idx(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 456, 40);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

}

impl std::fmt::Debug for Header {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("Header")
            .field("bbox_left", &self.bbox_left())
            .field("bbox_right", &self.bbox_right())
            .field("bbox_top", &self.bbox_top())
            .field("bbox_bottom", &self.bbox_bottom())
            .field("required_feature_first_idx", &self.required_feature_first_idx())
            .field("required_features_size", &self.required_features_size())
            .field("optional_feature_first_idx", &self.optional_feature_first_idx())
            .field("optional_features_size", &self.optional_features_size())
            .field("writingprogram_idx", &self.writingprogram_idx())
            .field("source_idx", &self.source_idx())
            .field("osmosis_replication_timestamp", &self.osmosis_replication_timestamp())
            .field("osmosis_replication_sequence_number", &self.osmosis_replication_sequence_number())
            .field("osmosis_replication_base_url_idx", &self.osmosis_replication_base_url_idx())
            .finish()
    }
}

impl std::cmp::PartialEq for Header {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.bbox_left() == other.bbox_left() &&        self.bbox_right() == other.bbox_right() &&        self.bbox_top() == other.bbox_top() &&        self.bbox_bottom() == other.bbox_bottom() &&        self.required_feature_first_idx() == other.required_feature_first_idx() &&        self.required_features_size() == other.required_features_size() &&        self.optional_feature_first_idx() == other.optional_feature_first_idx() &&        self.optional_features_size() == other.optional_features_size() &&        self.writingprogram_idx() == other.writingprogram_idx() &&        self.source_idx() == other.source_idx() &&        self.osmosis_replication_timestamp() == other.osmosis_replication_timestamp() &&        self.osmosis_replication_sequence_number() == other.osmosis_replication_sequence_number() &&        self.osmosis_replication_base_url_idx() == other.osmosis_replication_base_url_idx()     }
}

impl Header {
    /// Bounding box (min longitude scaled with `COORD_SCALE`)
    #[inline]
    #[allow(missing_docs)]
    pub fn set_bbox_left(&mut self, value: i64) {
        flatdata_write_bytes!(i64; value, self.data, 0, 40)
    }

    /// Bounding box (max longitude scaled with `COORD_SCALE`)
    #[inline]
    #[allow(missing_docs)]
    pub fn set_bbox_right(&mut self, value: i64) {
        flatdata_write_bytes!(i64; value, self.data, 40, 40)
    }

    /// Bounding box (max latitude scaled with `COORD_SCALE`)
    #[inline]
    #[allow(missing_docs)]
    pub fn set_bbox_top(&mut self, value: i64) {
        flatdata_write_bytes!(i64; value, self.data, 80, 40)
    }

    /// Bounding box (min latitude scaled with `COORD_SCALE`)
    #[inline]
    #[allow(missing_docs)]
    pub fn set_bbox_bottom(&mut self, value: i64) {
        flatdata_write_bytes!(i64; value, self.data, 120, 40)
    }

    /// Reference to the first required feature in `stringtable`.
    #[inline]
    #[allow(missing_docs)]
    pub fn set_required_feature_first_idx(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 160, 40)
    }

    /// Number of required features.
    #[inline]
    #[allow(missing_docs)]
    pub fn set_required_features_size(&mut self, value: u32) {
        flatdata_write_bytes!(u32; value, self.data, 200, 4)
    }

    /// Reference to the first optional feature in `stringtable`.
    #[inline]
    #[allow(missing_docs)]
    pub fn set_optional_feature_first_idx(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 204, 40)
    }

    /// Number of optional features.
    #[inline]
    #[allow(missing_docs)]
    pub fn set_optional_features_size(&mut self, value: u32) {
        flatdata_write_bytes!(u32; value, self.data, 244, 4)
    }

    /// Writing program used to write the data (reference to `stringtable`).
    #[inline]
    #[allow(missing_docs)]
    pub fn set_writingprogram_idx(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 248, 40)
    }

    /// The origin (source) of the data.
    #[inline]
    #[allow(missing_docs)]
    pub fn set_source_idx(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 288, 40)
    }

    /// Replication timestamp, expressed in seconds since the epoch.
/// See [`state.txt`].
///
/// [`state.txt`]: https://wiki.openstreetmap.org/wiki/Planet.osm/diffs#Minute.2C_Hour.2C_and_Day_Files_Organisation
    #[inline]
    #[allow(missing_docs)]
    pub fn set_osmosis_replication_timestamp(&mut self, value: i64) {
        flatdata_write_bytes!(i64; value, self.data, 328, 64)
    }

    /// Replication sequence number (`sequenceNumber` from [`state.txt`]).
///
/// [`state.txt`]: https://wiki.openstreetmap.org/wiki/Planet.osm/diffs#Minute.2C_Hour.2C_and_Day_Files_Organisation
    #[inline]
    #[allow(missing_docs)]
    pub fn set_osmosis_replication_sequence_number(&mut self, value: i64) {
        flatdata_write_bytes!(i64; value, self.data, 392, 64)
    }

    /// Replication base URL (reference to `stringtable`).
    #[inline]
    #[allow(missing_docs)]
    pub fn set_osmosis_replication_base_url_idx(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 456, 40)
    }


    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &Header) {
        self.set_bbox_left(other.bbox_left());
        self.set_bbox_right(other.bbox_right());
        self.set_bbox_top(other.bbox_top());
        self.set_bbox_bottom(other.bbox_bottom());
        self.set_required_feature_first_idx(other.required_feature_first_idx());
        self.set_required_features_size(other.required_features_size());
        self.set_optional_feature_first_idx(other.optional_feature_first_idx());
        self.set_optional_features_size(other.optional_features_size());
        self.set_writingprogram_idx(other.writingprogram_idx());
        self.set_source_idx(other.source_idx());
        self.set_osmosis_replication_timestamp(other.osmosis_replication_timestamp());
        self.set_osmosis_replication_sequence_number(other.osmosis_replication_sequence_number());
        self.set_osmosis_replication_base_url_idx(other.osmosis_replication_base_url_idx());
    }
}
/// A `(key, value)` attached to a `Node`, `Way`, or `Relation.
#[repr(transparent)]
#[derive(Clone)]
pub struct Tag {
    data: [u8; 10],
}

impl Tag {
    /// Unsafe since the struct might not be self-contained
    pub unsafe fn new_unchecked( ) -> Self {
        Self{data : [0; 10]}
    }
}

impl flatdata::Struct for Tag {
    unsafe fn create_unchecked( ) -> Self {
        Self{data : [0; 10]}
    }

    const SIZE_IN_BYTES: usize = 10;
    const IS_OVERLAPPING_WITH_NEXT : bool = false;
}

impl Tag {
    pub fn new( ) -> Self {
        Self{data : [0; 10]}
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes(data: &[u8; 10]) -> &Self {
        // Safety: This is safe since Tag is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes_mut(data: &mut [u8; 10]) -> &mut Self {
        // Safety: This is safe since Tag is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array
    pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 10 {
            assert_eq!(data.len(), 10);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *const [u8; 10];
        // Safety: We checked length before
        Ok(Self::from_bytes(unsafe { &*ptr }))
    }

    /// Create reference from byte array
    pub fn from_bytes_slice_mut(data: &mut [u8]) -> Result<&mut Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 10 {
            assert_eq!(data.len(), 10);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *mut [u8; 10];
        // Safety: We checked length before
        Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
    }

    pub fn as_bytes(&self) -> &[u8; 10] {
        &self.data
    }
}

impl Default for Tag {
    fn default( ) -> Self {
        Self::new( )
    }
}

unsafe impl flatdata::NoOverlap for Tag {}

impl Tag {
    /// Key index in `stringtable`
    #[inline]
    pub fn key_idx(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 40);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

    /// Value index in `stringtable`
    #[inline]
    pub fn value_idx(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 40, 40);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

}

impl std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("Tag")
            .field("key_idx", &self.key_idx())
            .field("value_idx", &self.value_idx())
            .finish()
    }
}

impl std::cmp::PartialEq for Tag {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.key_idx() == other.key_idx() &&        self.value_idx() == other.value_idx()     }
}

impl Tag {
    /// Key index in `stringtable`
    #[inline]
    #[allow(missing_docs)]
    pub fn set_key_idx(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 0, 40)
    }

    /// Value index in `stringtable`
    #[inline]
    #[allow(missing_docs)]
    pub fn set_value_idx(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 40, 40)
    }


    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &Tag) {
        self.set_key_idx(other.key_idx());
        self.set_value_idx(other.value_idx());
    }
}
/// A node is one of the core elements in the OpenStreetMap data model.
///
/// It consists of a single point in space defined by its latitude, longitude and node id.
///
/// See <https://wiki.openstreetmap.org/wiki/Node>.
#[repr(transparent)]
pub struct Node {
    data: [u8; 20],
}

impl Node {
    /// Unsafe since the struct might not be self-contained
    pub unsafe fn new_unchecked( ) -> Self {
        Self{data : [0; 20]}
    }
}

impl flatdata::Struct for Node {
    unsafe fn create_unchecked( ) -> Self {
        Self{data : [0; 20]}
    }

    const SIZE_IN_BYTES: usize = 20;
    const IS_OVERLAPPING_WITH_NEXT : bool = true;
}

impl flatdata::Overlap for Node {}

impl Node {
    /// Unique node ID
    #[inline]
    pub fn id(&self) -> i64 {
        let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 0, 40);
        unsafe { std::mem::transmute::<i64, i64>(value) }
    }

    /// Latitude (scaled with `COORD_SCALE`).
    #[inline]
    pub fn lat(&self) -> i64 {
        let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 40, 40);
        unsafe { std::mem::transmute::<i64, i64>(value) }
    }

    /// Longitude (scaled with `COORD_SCALE`).
    #[inline]
    pub fn lon(&self) -> i64 {
        let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 80, 40);
        unsafe { std::mem::transmute::<i64, i64>(value) }
    }

    /// First element of the range [`tags`].
    ///
    /// [`tags`]: #method.tags
    #[inline]
    pub fn tag_first_idx(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 120, 40);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

    /// Range of tags attached to this node.
///
/// The values of the range are indexes in the `tags_index` vector.
    #[inline]
    pub fn tags(&self) -> std::ops::Range<u64> {
        let start = flatdata_read_bytes!(u64, self.data.as_ptr(), 120, 40);
        let end = flatdata_read_bytes!(u64, self.data.as_ptr(), 120 + 20 * 8, 40);
        start..end
    }

}

impl std::fmt::Debug for Node {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("Node")
            .field("id", &self.id())
            .field("lat", &self.lat())
            .field("lon", &self.lon())
            .field("tag_first_idx", &self.tag_first_idx())
            .finish()
    }
}

impl std::cmp::PartialEq for Node {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id() &&        self.lat() == other.lat() &&        self.lon() == other.lon() &&        self.tag_first_idx() == other.tag_first_idx()     }
}

impl Node {
    /// Unique node ID
    #[inline]
    #[allow(missing_docs)]
    pub fn set_id(&mut self, value: i64) {
        flatdata_write_bytes!(i64; value, self.data, 0, 40)
    }

    /// Latitude (scaled with `COORD_SCALE`).
    #[inline]
    #[allow(missing_docs)]
    pub fn set_lat(&mut self, value: i64) {
        flatdata_write_bytes!(i64; value, self.data, 40, 40)
    }

    /// Longitude (scaled with `COORD_SCALE`).
    #[inline]
    #[allow(missing_docs)]
    pub fn set_lon(&mut self, value: i64) {
        flatdata_write_bytes!(i64; value, self.data, 80, 40)
    }

    /// First element of the range [`tags`].
    ///
    /// [`tags`]: struct.NodeRef.html#method.tags
    #[inline]
    #[allow(missing_docs)]
    pub fn set_tag_first_idx(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 120, 40)
    }


    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &Node) {
        self.set_id(other.id());
        self.set_lat(other.lat());
        self.set_lon(other.lon());
        self.set_tag_first_idx(other.tag_first_idx());
    }
}
/// Index of a node.
#[repr(transparent)]
#[derive(Clone)]
pub struct NodeIndex {
    data: [u8; 5],
}

impl NodeIndex {
    /// Unsafe since the struct might not be self-contained
    pub unsafe fn new_unchecked( ) -> Self {
        Self{data : [0; 5]}
    }
}

impl flatdata::Struct for NodeIndex {
    unsafe fn create_unchecked( ) -> Self {
        Self{data : [0; 5]}
    }

    const SIZE_IN_BYTES: usize = 5;
    const IS_OVERLAPPING_WITH_NEXT : bool = false;
}

impl NodeIndex {
    pub fn new( ) -> Self {
        Self{data : [0; 5]}
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes(data: &[u8; 5]) -> &Self {
        // Safety: This is safe since NodeIndex is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes_mut(data: &mut [u8; 5]) -> &mut Self {
        // Safety: This is safe since NodeIndex is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array
    pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 5 {
            assert_eq!(data.len(), 5);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *const [u8; 5];
        // Safety: We checked length before
        Ok(Self::from_bytes(unsafe { &*ptr }))
    }

    /// Create reference from byte array
    pub fn from_bytes_slice_mut(data: &mut [u8]) -> Result<&mut Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 5 {
            assert_eq!(data.len(), 5);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *mut [u8; 5];
        // Safety: We checked length before
        Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
    }

    pub fn as_bytes(&self) -> &[u8; 5] {
        &self.data
    }
}

impl Default for NodeIndex {
    fn default( ) -> Self {
        Self::new( )
    }
}

unsafe impl flatdata::NoOverlap for NodeIndex {}

impl NodeIndex {
    /// Index in the `nodes` vector.
    #[inline]
    pub fn value(&self) -> Option<u64> {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 40);
        let x = unsafe { std::mem::transmute::<u64, u64>(value) };
        Some(x).filter(|&x| x != super::osm::INVALID_IDX)
    }

}

impl std::fmt::Debug for NodeIndex {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("NodeIndex")
            .field("value", &self.value())
            .finish()
    }
}

impl std::cmp::PartialEq for NodeIndex {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.value() == other.value()     }
}

impl NodeIndex {
    /// Index in the `nodes` vector.
    #[inline]
    #[allow(missing_docs)]
    pub fn set_value(&mut self, value: Option<u64>) {
let value = value.unwrap_or(super::osm::INVALID_IDX);        flatdata_write_bytes!(u64; value, self.data, 0, 40)
    }


    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &NodeIndex) {
        self.set_value(other.value());
    }
}
/// A way is an ordered list of nodes.
///
/// See https://wiki.openstreetmap.org/wiki/Way.
#[repr(transparent)]
pub struct Way {
    data: [u8; 15],
}

impl Way {
    /// Unsafe since the struct might not be self-contained
    pub unsafe fn new_unchecked( ) -> Self {
        Self{data : [0; 15]}
    }
}

impl flatdata::Struct for Way {
    unsafe fn create_unchecked( ) -> Self {
        Self{data : [0; 15]}
    }

    const SIZE_IN_BYTES: usize = 15;
    const IS_OVERLAPPING_WITH_NEXT : bool = true;
}

impl flatdata::Overlap for Way {}

impl Way {
    /// Unique ID of the way.
    #[inline]
    pub fn id(&self) -> i64 {
        let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 0, 40);
        unsafe { std::mem::transmute::<i64, i64>(value) }
    }

    /// First element of the range [`tags`].
    ///
    /// [`tags`]: #method.tags
    #[inline]
    pub fn tag_first_idx(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 40, 40);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

    /// Range of tags attached to this node.
///
/// The values of the range are indexes in the `tags_index` vector.
    #[inline]
    pub fn tags(&self) -> std::ops::Range<u64> {
        let start = flatdata_read_bytes!(u64, self.data.as_ptr(), 40, 40);
        let end = flatdata_read_bytes!(u64, self.data.as_ptr(), 40 + 15 * 8, 40);
        start..end
    }

    /// First element of the range [`refs`].
    ///
    /// [`refs`]: #method.refs
    #[inline]
    pub fn ref_first_idx(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 80, 40);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

    /// Range of nodes this way consists of.
///
/// The values of the range are indexes in the `nodes_index` vector.
    #[inline]
    pub fn refs(&self) -> std::ops::Range<u64> {
        let start = flatdata_read_bytes!(u64, self.data.as_ptr(), 80, 40);
        let end = flatdata_read_bytes!(u64, self.data.as_ptr(), 80 + 15 * 8, 40);
        start..end
    }

}

impl std::fmt::Debug for Way {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("Way")
            .field("id", &self.id())
            .field("tag_first_idx", &self.tag_first_idx())
            .field("ref_first_idx", &self.ref_first_idx())
            .finish()
    }
}

impl std::cmp::PartialEq for Way {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id() &&        self.tag_first_idx() == other.tag_first_idx() &&        self.ref_first_idx() == other.ref_first_idx()     }
}

impl Way {
    /// Unique ID of the way.
    #[inline]
    #[allow(missing_docs)]
    pub fn set_id(&mut self, value: i64) {
        flatdata_write_bytes!(i64; value, self.data, 0, 40)
    }

    /// First element of the range [`tags`].
    ///
    /// [`tags`]: struct.WayRef.html#method.tags
    #[inline]
    #[allow(missing_docs)]
    pub fn set_tag_first_idx(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 40, 40)
    }

    /// First element of the range [`refs`].
    ///
    /// [`refs`]: struct.WayRef.html#method.refs
    #[inline]
    #[allow(missing_docs)]
    pub fn set_ref_first_idx(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 80, 40)
    }


    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &Way) {
        self.set_id(other.id());
        self.set_tag_first_idx(other.tag_first_idx());
        self.set_ref_first_idx(other.ref_first_idx());
    }
}
/// Index of a tag.
#[repr(transparent)]
#[derive(Clone)]
pub struct TagIndex {
    data: [u8; 5],
}

impl TagIndex {
    /// Unsafe since the struct might not be self-contained
    pub unsafe fn new_unchecked( ) -> Self {
        Self{data : [0; 5]}
    }
}

impl flatdata::Struct for TagIndex {
    unsafe fn create_unchecked( ) -> Self {
        Self{data : [0; 5]}
    }

    const SIZE_IN_BYTES: usize = 5;
    const IS_OVERLAPPING_WITH_NEXT : bool = false;
}

impl TagIndex {
    pub fn new( ) -> Self {
        Self{data : [0; 5]}
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes(data: &[u8; 5]) -> &Self {
        // Safety: This is safe since TagIndex is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes_mut(data: &mut [u8; 5]) -> &mut Self {
        // Safety: This is safe since TagIndex is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array
    pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 5 {
            assert_eq!(data.len(), 5);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *const [u8; 5];
        // Safety: We checked length before
        Ok(Self::from_bytes(unsafe { &*ptr }))
    }

    /// Create reference from byte array
    pub fn from_bytes_slice_mut(data: &mut [u8]) -> Result<&mut Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 5 {
            assert_eq!(data.len(), 5);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *mut [u8; 5];
        // Safety: We checked length before
        Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
    }

    pub fn as_bytes(&self) -> &[u8; 5] {
        &self.data
    }
}

impl Default for TagIndex {
    fn default( ) -> Self {
        Self::new( )
    }
}

unsafe impl flatdata::NoOverlap for TagIndex {}

impl TagIndex {
    /// Index in the `tags` vector.
    #[inline]
    pub fn value(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 40);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

}

impl std::fmt::Debug for TagIndex {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("TagIndex")
            .field("value", &self.value())
            .finish()
    }
}

impl std::cmp::PartialEq for TagIndex {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.value() == other.value()     }
}

impl TagIndex {
    /// Index in the `tags` vector.
    #[inline]
    #[allow(missing_docs)]
    pub fn set_value(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 0, 40)
    }


    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &TagIndex) {
        self.set_value(other.value());
    }
}
/// Node member of a relation.
#[repr(transparent)]
#[derive(Clone)]
pub struct NodeMember {
    data: [u8; 10],
}

impl NodeMember {
    /// Unsafe since the struct might not be self-contained
    pub unsafe fn new_unchecked( ) -> Self {
        Self{data : [0; 10]}
    }
}

impl flatdata::Struct for NodeMember {
    unsafe fn create_unchecked( ) -> Self {
        Self{data : [0; 10]}
    }

    const SIZE_IN_BYTES: usize = 10;
    const IS_OVERLAPPING_WITH_NEXT : bool = false;
}

impl NodeMember {
    pub fn new( ) -> Self {
        Self{data : [0; 10]}
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes(data: &[u8; 10]) -> &Self {
        // Safety: This is safe since NodeMember is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes_mut(data: &mut [u8; 10]) -> &mut Self {
        // Safety: This is safe since NodeMember is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array
    pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 10 {
            assert_eq!(data.len(), 10);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *const [u8; 10];
        // Safety: We checked length before
        Ok(Self::from_bytes(unsafe { &*ptr }))
    }

    /// Create reference from byte array
    pub fn from_bytes_slice_mut(data: &mut [u8]) -> Result<&mut Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 10 {
            assert_eq!(data.len(), 10);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *mut [u8; 10];
        // Safety: We checked length before
        Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
    }

    pub fn as_bytes(&self) -> &[u8; 10] {
        &self.data
    }
}

impl Default for NodeMember {
    fn default( ) -> Self {
        Self::new( )
    }
}

unsafe impl flatdata::NoOverlap for NodeMember {}

impl NodeMember {
    /// Index of the node in the `nodes` vector.
    #[inline]
    pub fn node_idx(&self) -> Option<u64> {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 40);
        let x = unsafe { std::mem::transmute::<u64, u64>(value) };
        Some(x).filter(|&x| x != super::osm::INVALID_IDX)
    }

    /// Optional textual field describing the function of the node in the relation.
///
/// Index in `stringtable`.
    #[inline]
    pub fn role_idx(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 40, 40);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

}

impl std::fmt::Debug for NodeMember {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("NodeMember")
            .field("node_idx", &self.node_idx())
            .field("role_idx", &self.role_idx())
            .finish()
    }
}

impl std::cmp::PartialEq for NodeMember {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.node_idx() == other.node_idx() &&        self.role_idx() == other.role_idx()     }
}

impl NodeMember {
    /// Index of the node in the `nodes` vector.
    #[inline]
    #[allow(missing_docs)]
    pub fn set_node_idx(&mut self, value: Option<u64>) {
let value = value.unwrap_or(super::osm::INVALID_IDX);        flatdata_write_bytes!(u64; value, self.data, 0, 40)
    }

    /// Optional textual field describing the function of the node in the relation.
///
/// Index in `stringtable`.
    #[inline]
    #[allow(missing_docs)]
    pub fn set_role_idx(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 40, 40)
    }


    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &NodeMember) {
        self.set_node_idx(other.node_idx());
        self.set_role_idx(other.role_idx());
    }
}
/// Way member of a relation.
#[repr(transparent)]
#[derive(Clone)]
pub struct WayMember {
    data: [u8; 10],
}

impl WayMember {
    /// Unsafe since the struct might not be self-contained
    pub unsafe fn new_unchecked( ) -> Self {
        Self{data : [0; 10]}
    }
}

impl flatdata::Struct for WayMember {
    unsafe fn create_unchecked( ) -> Self {
        Self{data : [0; 10]}
    }

    const SIZE_IN_BYTES: usize = 10;
    const IS_OVERLAPPING_WITH_NEXT : bool = false;
}

impl WayMember {
    pub fn new( ) -> Self {
        Self{data : [0; 10]}
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes(data: &[u8; 10]) -> &Self {
        // Safety: This is safe since WayMember is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes_mut(data: &mut [u8; 10]) -> &mut Self {
        // Safety: This is safe since WayMember is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array
    pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 10 {
            assert_eq!(data.len(), 10);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *const [u8; 10];
        // Safety: We checked length before
        Ok(Self::from_bytes(unsafe { &*ptr }))
    }

    /// Create reference from byte array
    pub fn from_bytes_slice_mut(data: &mut [u8]) -> Result<&mut Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 10 {
            assert_eq!(data.len(), 10);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *mut [u8; 10];
        // Safety: We checked length before
        Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
    }

    pub fn as_bytes(&self) -> &[u8; 10] {
        &self.data
    }
}

impl Default for WayMember {
    fn default( ) -> Self {
        Self::new( )
    }
}

unsafe impl flatdata::NoOverlap for WayMember {}

impl WayMember {
    /// Index of the way in the `ways` vector.
    #[inline]
    pub fn way_idx(&self) -> Option<u64> {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 40);
        let x = unsafe { std::mem::transmute::<u64, u64>(value) };
        Some(x).filter(|&x| x != super::osm::INVALID_IDX)
    }

    /// Optional textual field describing the function of the way in the relation.
///
/// Index in `stringtable`.
    #[inline]
    pub fn role_idx(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 40, 40);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

}

impl std::fmt::Debug for WayMember {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("WayMember")
            .field("way_idx", &self.way_idx())
            .field("role_idx", &self.role_idx())
            .finish()
    }
}

impl std::cmp::PartialEq for WayMember {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.way_idx() == other.way_idx() &&        self.role_idx() == other.role_idx()     }
}

impl WayMember {
    /// Index of the way in the `ways` vector.
    #[inline]
    #[allow(missing_docs)]
    pub fn set_way_idx(&mut self, value: Option<u64>) {
let value = value.unwrap_or(super::osm::INVALID_IDX);        flatdata_write_bytes!(u64; value, self.data, 0, 40)
    }

    /// Optional textual field describing the function of the way in the relation.
///
/// Index in `stringtable`.
    #[inline]
    #[allow(missing_docs)]
    pub fn set_role_idx(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 40, 40)
    }


    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &WayMember) {
        self.set_way_idx(other.way_idx());
        self.set_role_idx(other.role_idx());
    }
}
/// Relation member of a relation.
#[repr(transparent)]
#[derive(Clone)]
pub struct RelationMember {
    data: [u8; 10],
}

impl RelationMember {
    /// Unsafe since the struct might not be self-contained
    pub unsafe fn new_unchecked( ) -> Self {
        Self{data : [0; 10]}
    }
}

impl flatdata::Struct for RelationMember {
    unsafe fn create_unchecked( ) -> Self {
        Self{data : [0; 10]}
    }

    const SIZE_IN_BYTES: usize = 10;
    const IS_OVERLAPPING_WITH_NEXT : bool = false;
}

impl RelationMember {
    pub fn new( ) -> Self {
        Self{data : [0; 10]}
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes(data: &[u8; 10]) -> &Self {
        // Safety: This is safe since RelationMember is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array of matching size
    pub fn from_bytes_mut(data: &mut [u8; 10]) -> &mut Self {
        // Safety: This is safe since RelationMember is repr(transparent)
        unsafe{ std::mem::transmute( data ) }
    }

    /// Create reference from byte array
    pub fn from_bytes_slice(data: &[u8]) -> Result<&Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 10 {
            assert_eq!(data.len(), 10);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *const [u8; 10];
        // Safety: We checked length before
        Ok(Self::from_bytes(unsafe { &*ptr }))
    }

    /// Create reference from byte array
    pub fn from_bytes_slice_mut(data: &mut [u8]) -> Result<&mut Self, flatdata::ResourceStorageError> {
        // We cannot rely on TryFrom here, since it does not yet support > 33 bytes
        if data.len() < 10 {
            assert_eq!(data.len(), 10);
            return Err(flatdata::ResourceStorageError::UnexpectedDataSize);
        }
        let ptr = data.as_ptr() as *mut [u8; 10];
        // Safety: We checked length before
        Ok(Self::from_bytes_mut(unsafe { &mut *ptr }))
    }

    pub fn as_bytes(&self) -> &[u8; 10] {
        &self.data
    }
}

impl Default for RelationMember {
    fn default( ) -> Self {
        Self::new( )
    }
}

unsafe impl flatdata::NoOverlap for RelationMember {}

impl RelationMember {
    /// Index of the relation in the `relations` vector.
    #[inline]
    pub fn relation_idx(&self) -> Option<u64> {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 40);
        let x = unsafe { std::mem::transmute::<u64, u64>(value) };
        Some(x).filter(|&x| x != super::osm::INVALID_IDX)
    }

    /// Optional textual field describing the function of the relation in the parent relation.
///
/// Index in `stringtable`.
    #[inline]
    pub fn role_idx(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 40, 40);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

}

impl std::fmt::Debug for RelationMember {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("RelationMember")
            .field("relation_idx", &self.relation_idx())
            .field("role_idx", &self.role_idx())
            .finish()
    }
}

impl std::cmp::PartialEq for RelationMember {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.relation_idx() == other.relation_idx() &&        self.role_idx() == other.role_idx()     }
}

impl RelationMember {
    /// Index of the relation in the `relations` vector.
    #[inline]
    #[allow(missing_docs)]
    pub fn set_relation_idx(&mut self, value: Option<u64>) {
let value = value.unwrap_or(super::osm::INVALID_IDX);        flatdata_write_bytes!(u64; value, self.data, 0, 40)
    }

    /// Optional textual field describing the function of the relation in the parent relation.
///
/// Index in `stringtable`.
    #[inline]
    #[allow(missing_docs)]
    pub fn set_role_idx(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 40, 40)
    }


    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &RelationMember) {
        self.set_relation_idx(other.relation_idx());
        self.set_role_idx(other.role_idx());
    }
}
/// A relation is an ordered list of one or more nodes, ways and/or relations as members.
///
/// See https://wiki.openstreetmap.org/wiki/Relation.
#[repr(transparent)]
pub struct Relation {
    data: [u8; 10],
}

impl Relation {
    /// Unsafe since the struct might not be self-contained
    pub unsafe fn new_unchecked( ) -> Self {
        Self{data : [0; 10]}
    }
}

impl flatdata::Struct for Relation {
    unsafe fn create_unchecked( ) -> Self {
        Self{data : [0; 10]}
    }

    const SIZE_IN_BYTES: usize = 10;
    const IS_OVERLAPPING_WITH_NEXT : bool = true;
}

impl flatdata::Overlap for Relation {}

impl Relation {
    /// Unique ID of the relation.
    #[inline]
    pub fn id(&self) -> i64 {
        let value = flatdata_read_bytes!(i64, self.data.as_ptr(), 0, 40);
        unsafe { std::mem::transmute::<i64, i64>(value) }
    }

    /// First element of the range [`tags`].
    ///
    /// [`tags`]: #method.tags
    #[inline]
    pub fn tag_first_idx(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 40, 40);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

    /// Range of tags attached to this relation.
///
/// The values of the range are indexes in the `tags` vector.
    #[inline]
    pub fn tags(&self) -> std::ops::Range<u64> {
        let start = flatdata_read_bytes!(u64, self.data.as_ptr(), 40, 40);
        let end = flatdata_read_bytes!(u64, self.data.as_ptr(), 40 + 10 * 8, 40);
        start..end
    }

}

impl std::fmt::Debug for Relation {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("Relation")
            .field("id", &self.id())
            .field("tag_first_idx", &self.tag_first_idx())
            .finish()
    }
}

impl std::cmp::PartialEq for Relation {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id() &&        self.tag_first_idx() == other.tag_first_idx()     }
}

impl Relation {
    /// Unique ID of the relation.
    #[inline]
    #[allow(missing_docs)]
    pub fn set_id(&mut self, value: i64) {
        flatdata_write_bytes!(i64; value, self.data, 0, 40)
    }

    /// First element of the range [`tags`].
    ///
    /// [`tags`]: struct.RelationRef.html#method.tags
    #[inline]
    #[allow(missing_docs)]
    pub fn set_tag_first_idx(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 40, 40)
    }


    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &Relation) {
        self.set_id(other.id());
        self.set_tag_first_idx(other.tag_first_idx());
    }
}


/// Enum for read-only heterogeneous access to elements in a
/// bucket of the [`relation_members`] resource.
///
/// [`relation_members`]: struct.Archive{.osm.Osm}.html#method.relation_members
#[derive(Clone, PartialEq)]
pub enum RelationMembersRef<'a> {
    #[allow(missing_docs)]
    NodeMember(&'a super::osm::NodeMember),    #[allow(missing_docs)]
    WayMember(&'a super::osm::WayMember),    #[allow(missing_docs)]
    RelationMember(&'a super::osm::RelationMember),}

impl<'a> ::std::fmt::Debug for RelationMembersRef<'a> {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        match *self {
            RelationMembersRef::NodeMember(ref inner) => write!(f, "{:?}", inner),
            RelationMembersRef::WayMember(ref inner) => write!(f, "{:?}", inner),
            RelationMembersRef::RelationMember(ref inner) => write!(f, "{:?}", inner),
        }
    }
}

impl<'a> flatdata::VariadicRef for RelationMembersRef<'a> {
    #[inline]
    fn size_in_bytes(&self) -> usize {
        match *self {
            RelationMembersRef::NodeMember(_) => <super::osm::NodeMember as flatdata::Struct>::SIZE_IN_BYTES,
            RelationMembersRef::WayMember(_) => <super::osm::WayMember as flatdata::Struct>::SIZE_IN_BYTES,
            RelationMembersRef::RelationMember(_) => <super::osm::RelationMember as flatdata::Struct>::SIZE_IN_BYTES,
        }
    }
}

/// Builder of buckets in the [`relation_members`] resource.
///
/// Refers to a single bucket in the [`relation_members`] multivector and
/// provides methods for adding heterogeneous data to the bucket.
///
/// [`relation_members`]: struct.Archive{.osm.Osm}.html#method.relation_members
pub struct RelationMembersBuilder<'a> {
    data: &'a mut Vec<u8>
}

impl<'a> RelationMembersBuilder<'a> {
    /// Adds data of the type [`NodeMember`] to the bucket.
    ///
    /// [`NodeMember`]: struct.NodeMember.html
    #[inline]
    pub fn add_node_member<'b>(&'b mut self) -> &'b mut super::osm::NodeMember {
        let old_len = self.data.len();
        let increment = 1 + <super::osm::NodeMember as flatdata::Struct>::SIZE_IN_BYTES;
        self.data.resize(old_len + increment, 0);
        self.data[old_len] = 0;
        let slice = &mut self.data[1 + old_len..];
        super::osm::NodeMember::from_bytes_slice_mut(slice).expect("Logic error: Cannot create super::osm::NodeMember from slice")
    }
    /// Adds data of the type [`WayMember`] to the bucket.
    ///
    /// [`WayMember`]: struct.WayMember.html
    #[inline]
    pub fn add_way_member<'b>(&'b mut self) -> &'b mut super::osm::WayMember {
        let old_len = self.data.len();
        let increment = 1 + <super::osm::WayMember as flatdata::Struct>::SIZE_IN_BYTES;
        self.data.resize(old_len + increment, 0);
        self.data[old_len] = 1;
        let slice = &mut self.data[1 + old_len..];
        super::osm::WayMember::from_bytes_slice_mut(slice).expect("Logic error: Cannot create super::osm::WayMember from slice")
    }
    /// Adds data of the type [`RelationMember`] to the bucket.
    ///
    /// [`RelationMember`]: struct.RelationMember.html
    #[inline]
    pub fn add_relation_member<'b>(&'b mut self) -> &'b mut super::osm::RelationMember {
        let old_len = self.data.len();
        let increment = 1 + <super::osm::RelationMember as flatdata::Struct>::SIZE_IN_BYTES;
        self.data.resize(old_len + increment, 0);
        self.data[old_len] = 2;
        let slice = &mut self.data[1 + old_len..];
        super::osm::RelationMember::from_bytes_slice_mut(slice).expect("Logic error: Cannot create super::osm::RelationMember from slice")
    }
}

/// Variadic struct attached to the [`relation_members`] archive resource.
///
/// It unifies the following data types:
//
/// * [`NodeMember`]
/// * [`WayMember`]
/// * [`RelationMember`]
///
/// ## Access pattern
///
/// This structure is used as a template parameter in [`relation_members`] multivector/
/// multiarray view. It does not contain any data, instead it references
///
/// * [`RelationMembersRef`] for the read-only heterogeneous access, and
/// * [`RelationMembersBuilder`] for the mutable builder pattern access.
///
/// [`relation_members`]: struct.Archive{.osm.Osm}.html#method.relation_members
/// [`RelationMembersRef`]: enum.RelationMembersRef.html
/// [`RelationMembersBuilder`]: struct.RelationMembersBuilder.html
/// [`NodeMember`]: struct.NodeMember.html
/// [`WayMember`]: struct.WayMember.html
/// [`RelationMember`]: struct.RelationMember.html
#[derive(Clone)]
pub struct RelationMembers {}

impl flatdata::VariadicIndex for RelationMembers {
    type Index = super::_builtin::multivector::IndexType40;
}

impl<'a> flatdata::VariadicStruct<'a> for RelationMembers {
    type Item = RelationMembersRef<'a>;

    #[inline]
    fn create(index: flatdata::TypeIndex, data: &'a [u8]) -> Self::Item
    {
        match index {
                0 => RelationMembersRef::NodeMember(super::osm::NodeMember::from_bytes_slice(&data).expect("Corrupted data")),
                1 => RelationMembersRef::WayMember(super::osm::WayMember::from_bytes_slice(&data).expect("Corrupted data")),
                2 => RelationMembersRef::RelationMember(super::osm::RelationMember::from_bytes_slice(&data).expect("Corrupted data")),
            _ => panic!("invalid type index {} for variadic type RelationMembersRef", index),
        }
    }

    type ItemMut = RelationMembersBuilder<'a>;

    #[inline]
    fn create_mut(data: &'a mut Vec<u8>) -> Self::ItemMut
    {
        Self::ItemMut { data }
    }
}

/// OSM data archive
///
/// Relations and relation members are indexed with the same index, i.e.
/// a relation at index `i` in the vector `relations` has the members
/// at index `i` in the multivector `relation_members`.
///
/// All 1:n relationships are modeled in-place by using an additional index. This is a
/// common pattern in flatdata. For example, a node might have multiple tags attached
/// to it. To model this, a node in `nodes` references the first tag attached to it
/// by storing an index in the `tags_index` vector. The next node in `nodes` again
/// references its first tag, which is the last tag (exclusive) of the previous node.
///
/// ```text
/// nodes:      [ ..., n_1, n_2, ... ]
///                     |    |
///                     |    +-------+
///                     v            v
/// tags_index: [ ..., t_11, t_12, ..., t_1n, t_21, ... t_2m, ... ]
/// ```
#[derive(Clone)]
pub struct Osm {
    _storage: flatdata::StorageHandle,
    header : &'static super::osm::Header,
    nodes : &'static [super::osm::Node],
    ways : &'static [super::osm::Way],
    relations : &'static [super::osm::Relation],
    relation_members : flatdata::MultiArrayView<'static, RelationMembers>,
    tags : &'static [super::osm::Tag],
    tags_index : &'static [super::osm::TagIndex],
    nodes_index : &'static [super::osm::NodeIndex],
    stringtable : flatdata::RawData<'static>,
}

impl Osm {
    fn signature_name(archive_name: &str) -> String {
        format!("{}.archive", archive_name)
    }

    /// Header which contains the metadata attached to the archive.
    #[inline]
    pub fn header(&self) -> &super::osm::Header {
        self.header
    }

    /// List of nodes.
///
/// A node references a range of tags in the `tags_index` vector.
    #[inline]
    pub fn nodes(&self) -> &[super::osm::Node] {
        self.nodes
    }

    /// List of ways.
///
/// A way references
///
/// * a range of tags in the `tags_index` vector, and
/// * a range of nodes in the `nodes_index` vector.
    #[inline]
    pub fn ways(&self) -> &[super::osm::Way] {
        self.ways
    }

    /// List of relations.
///
/// A relation references a range of tags in `tags_index` vectors.
/// Members are attached to a relation implicitly: members that belong to a
/// relation at index `i` are at index `i` in the `relation_members` multivector.
    #[inline]
    pub fn relations(&self) -> &[super::osm::Relation] {
        self.relations
    }

    /// Members attached to relations.
///
/// An index in this multivector corresponds to an index in the `relations` vector.
///
/// A member has a variadic type: `NodeMember`, `WayMember` or `RelationMember`.
/// Each type references its role in the `stringtable` raw data. Additionally,
///
/// * a node member references a node in the `nodes` vector,
/// * a way member references a way in the `ways` vector,
/// * a relation member references a relation in the `relations` vector.
    #[inline]
    pub fn relation_members(&self) -> &flatdata::MultiArrayView<RelationMembers> {
        &self.relation_members
    }

    /// List of tags.
///
/// A tag references its key and value in the `stringtable` raw data.
    #[inline]
    pub fn tags(&self) -> &[super::osm::Tag] {
        self.tags
    }

    /// Auxiliary index of tags to model 1:n relationships between nodes, ways, relations
/// and tags.
    #[inline]
    pub fn tags_index(&self) -> &[super::osm::TagIndex] {
        self.tags_index
    }

    /// Auxiliary index of nodes to model 1:n relationship between ways and nodes.
    #[inline]
    pub fn nodes_index(&self) -> &[super::osm::NodeIndex] {
        self.nodes_index
    }

    /// List of strings separated by `\0`.
    #[inline]
    pub fn stringtable(&self) -> flatdata::RawData {
        self.stringtable
    }

}

impl ::std::fmt::Debug for Osm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct("Osm")
            .field("header", &self.header())
            .field("nodes", &self.nodes())
            .field("ways", &self.ways())
            .field("relations", &self.relations())
            .field("relation_members", &self.relation_members())
            .field("tags", &self.tags())
            .field("tags_index", &self.tags_index())
            .field("nodes_index", &self.nodes_index())
            .field("stringtable", &self.stringtable())
            .finish()
    }
}

impl Osm {
    pub fn open(storage: flatdata::StorageHandle)
        -> ::std::result::Result<Self, flatdata::ResourceStorageError>
    {
        #[allow(unused_imports)]
        use flatdata::SliceExt;
        // extend lifetime since Rust cannot know that we reference a cache here
        #[allow(unused_variables)]
        let extend = |x : Result<&[u8], flatdata::ResourceStorageError>| -> Result<&'static [u8], flatdata::ResourceStorageError> {x.map(|x| unsafe{std::mem::transmute(x)})};

        storage.read(&Self::signature_name("Osm"), schema::osm::OSM)?;

        let resource = extend(storage.read("header", schema::osm::resources::HEADER));
        let header = resource.map(|x| super::osm::Header::from_bytes_slice(x))??;
        let resource = extend(storage.read("nodes", schema::osm::resources::NODES));
        let nodes = resource.map(|x| <&[super::osm::Node]>::from_bytes(x))??;
        let size = nodes.len();
        if size > 1099511627776 { return Err(flatdata::ResourceStorageError::TooBig{resource_name: "nodes", size}); }
        let resource = extend(storage.read("ways", schema::osm::resources::WAYS));
        let ways = resource.map(|x| <&[super::osm::Way]>::from_bytes(x))??;
        let size = ways.len();
        if size > 1099511627776 { return Err(flatdata::ResourceStorageError::TooBig{resource_name: "ways", size}); }
        let resource = extend(storage.read("relations", schema::osm::resources::RELATIONS));
        let relations = resource.map(|x| <&[super::osm::Relation]>::from_bytes(x))??;
        let size = relations.len();
        if size > 1099511627776 { return Err(flatdata::ResourceStorageError::TooBig{resource_name: "relations", size}); }
        let relation_members = {
            let index_schema = &format!("index({})", schema::osm::resources::RELATION_MEMBERS);
            let index = extend(storage.read("relation_members_index", &index_schema));
            let data = extend(storage.read("relation_members", schema::osm::resources::RELATION_MEMBERS));
            let result = match (index, data) {
                (Ok(index), Ok(data)) => {
                    Ok(flatdata::MultiArrayView::new(
                        <&[super::_builtin::multivector::IndexType40]>::from_bytes(index)?,
                        data
                    ))
                }
                (Ok(_), Err(x)) | (Err(x), Ok(_)) => {return Err(x);}
                (Err(x), Err(_)) => Err(x),
            };
            result?
        };
        let resource = extend(storage.read("tags", schema::osm::resources::TAGS));
        let tags = resource.map(|x| <&[super::osm::Tag]>::from_bytes(x))??;
        let size = tags.len();
        if size > 1099511627776 { return Err(flatdata::ResourceStorageError::TooBig{resource_name: "tags", size}); }
        let resource = extend(storage.read("tags_index", schema::osm::resources::TAGS_INDEX));
        let tags_index = resource.map(|x| <&[super::osm::TagIndex]>::from_bytes(x))??;
        let size = tags_index.len();
        if size > 1099511627776 { return Err(flatdata::ResourceStorageError::TooBig{resource_name: "tags_index", size}); }
        let resource = extend(storage.read("nodes_index", schema::osm::resources::NODES_INDEX));
        let nodes_index = resource.map(|x| <&[super::osm::NodeIndex]>::from_bytes(x))??;
        let size = nodes_index.len();
        if size > 1099511627776 { return Err(flatdata::ResourceStorageError::TooBig{resource_name: "nodes_index", size}); }
        let resource = extend(storage.read("stringtable", schema::osm::resources::STRINGTABLE));
        let stringtable = resource.map(|x| flatdata::RawData::new(x))?;
        let size = stringtable.len();
        if size > 1099511627776 { return Err(flatdata::ResourceStorageError::TooBig{resource_name: "stringtable", size}); }

        Ok(Self {
            _storage: storage,
            header,
            nodes,
            ways,
            relations,
            relation_members,
            tags,
            tags_index,
            nodes_index,
            stringtable,
        })
    }
}

/// Builder for creating [`Osm`] archives.
///
///[`Osm`]: struct.Osm.html
#[derive(Clone, Debug)]
pub struct OsmBuilder {
    storage: flatdata::StorageHandle
}

impl OsmBuilder {
    #[inline]
    /// Stores [`header`] in the archive.
    ///
    /// [`header`]: struct.Osm.html#method.header
    /// Stores [`header`] in the archive.
    pub fn set_header(&self, resource: &super::osm::Header) -> ::std::io::Result<()> {
        let data = resource.as_bytes();
        self.storage.write("header", schema::osm::resources::HEADER, data)
    }

    #[inline]
    /// Stores [`nodes`] in the archive.
    ///
    /// [`nodes`]: struct.Osm.html#method.nodes
    pub fn set_nodes(&self, vector: &[super::osm::Node]) -> ::std::io::Result<()> {
        use flatdata::SliceExt;
        self.storage.write("nodes", schema::osm::resources::NODES, vector.as_bytes())
    }

    /// Opens [`nodes`] in the archive for buffered writing.
    ///
    /// Elements can be added to the vector until the [`ExternalVector::close`] method
    /// is called. To flush the data fully into the archive, this method must be called
    /// in the end.
    ///
    /// [`nodes`]: struct.Osm.html#method.nodes
    /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
    #[inline]
    pub fn start_nodes(&self) -> ::std::io::Result<flatdata::ExternalVector<super::osm::Node>> {
        flatdata::create_external_vector(&*self.storage, "nodes", schema::osm::resources::NODES)
    }

    #[inline]
    /// Stores [`ways`] in the archive.
    ///
    /// [`ways`]: struct.Osm.html#method.ways
    pub fn set_ways(&self, vector: &[super::osm::Way]) -> ::std::io::Result<()> {
        use flatdata::SliceExt;
        self.storage.write("ways", schema::osm::resources::WAYS, vector.as_bytes())
    }

    /// Opens [`ways`] in the archive for buffered writing.
    ///
    /// Elements can be added to the vector until the [`ExternalVector::close`] method
    /// is called. To flush the data fully into the archive, this method must be called
    /// in the end.
    ///
    /// [`ways`]: struct.Osm.html#method.ways
    /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
    #[inline]
    pub fn start_ways(&self) -> ::std::io::Result<flatdata::ExternalVector<super::osm::Way>> {
        flatdata::create_external_vector(&*self.storage, "ways", schema::osm::resources::WAYS)
    }

    #[inline]
    /// Stores [`relations`] in the archive.
    ///
    /// [`relations`]: struct.Osm.html#method.relations
    pub fn set_relations(&self, vector: &[super::osm::Relation]) -> ::std::io::Result<()> {
        use flatdata::SliceExt;
        self.storage.write("relations", schema::osm::resources::RELATIONS, vector.as_bytes())
    }

    /// Opens [`relations`] in the archive for buffered writing.
    ///
    /// Elements can be added to the vector until the [`ExternalVector::close`] method
    /// is called. To flush the data fully into the archive, this method must be called
    /// in the end.
    ///
    /// [`relations`]: struct.Osm.html#method.relations
    /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
    #[inline]
    pub fn start_relations(&self) -> ::std::io::Result<flatdata::ExternalVector<super::osm::Relation>> {
        flatdata::create_external_vector(&*self.storage, "relations", schema::osm::resources::RELATIONS)
    }

    /// Opens [`relation_members`] in the archive for buffered writing.
    ///
    /// Elements can be added to the multivector until the [`MultiVector::close`] method
    /// is called. To flush the data fully into the archive, this method must be called
    /// in the end.
    ///
    /// [`relation_members`]: struct.Osm.html#method.relation_members
    /// [`MultiVector::close`]: flatdata/struct.MultiVector.html#method.close
    #[inline]
    pub fn start_relation_members(&self) -> ::std::io::Result<flatdata::MultiVector<RelationMembers>> {
        flatdata::create_multi_vector(&*self.storage, "relation_members", schema::osm::resources::RELATION_MEMBERS)
    }

    #[inline]
    /// Stores [`tags`] in the archive.
    ///
    /// [`tags`]: struct.Osm.html#method.tags
    pub fn set_tags(&self, vector: &[super::osm::Tag]) -> ::std::io::Result<()> {
        use flatdata::SliceExt;
        self.storage.write("tags", schema::osm::resources::TAGS, vector.as_bytes())
    }

    /// Opens [`tags`] in the archive for buffered writing.
    ///
    /// Elements can be added to the vector until the [`ExternalVector::close`] method
    /// is called. To flush the data fully into the archive, this method must be called
    /// in the end.
    ///
    /// [`tags`]: struct.Osm.html#method.tags
    /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
    #[inline]
    pub fn start_tags(&self) -> ::std::io::Result<flatdata::ExternalVector<super::osm::Tag>> {
        flatdata::create_external_vector(&*self.storage, "tags", schema::osm::resources::TAGS)
    }

    #[inline]
    /// Stores [`tags_index`] in the archive.
    ///
    /// [`tags_index`]: struct.Osm.html#method.tags_index
    pub fn set_tags_index(&self, vector: &[super::osm::TagIndex]) -> ::std::io::Result<()> {
        use flatdata::SliceExt;
        self.storage.write("tags_index", schema::osm::resources::TAGS_INDEX, vector.as_bytes())
    }

    /// Opens [`tags_index`] in the archive for buffered writing.
    ///
    /// Elements can be added to the vector until the [`ExternalVector::close`] method
    /// is called. To flush the data fully into the archive, this method must be called
    /// in the end.
    ///
    /// [`tags_index`]: struct.Osm.html#method.tags_index
    /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
    #[inline]
    pub fn start_tags_index(&self) -> ::std::io::Result<flatdata::ExternalVector<super::osm::TagIndex>> {
        flatdata::create_external_vector(&*self.storage, "tags_index", schema::osm::resources::TAGS_INDEX)
    }

    #[inline]
    /// Stores [`nodes_index`] in the archive.
    ///
    /// [`nodes_index`]: struct.Osm.html#method.nodes_index
    pub fn set_nodes_index(&self, vector: &[super::osm::NodeIndex]) -> ::std::io::Result<()> {
        use flatdata::SliceExt;
        self.storage.write("nodes_index", schema::osm::resources::NODES_INDEX, vector.as_bytes())
    }

    /// Opens [`nodes_index`] in the archive for buffered writing.
    ///
    /// Elements can be added to the vector until the [`ExternalVector::close`] method
    /// is called. To flush the data fully into the archive, this method must be called
    /// in the end.
    ///
    /// [`nodes_index`]: struct.Osm.html#method.nodes_index
    /// [`ExternalVector::close`]: flatdata/struct.ExternalVector.html#method.close
    #[inline]
    pub fn start_nodes_index(&self) -> ::std::io::Result<flatdata::ExternalVector<super::osm::NodeIndex>> {
        flatdata::create_external_vector(&*self.storage, "nodes_index", schema::osm::resources::NODES_INDEX)
    }

    /// Stores [`stringtable`] in the archive.
    ///
    /// [`stringtable`]: struct.Osm.html#method.stringtable
    #[inline]
    pub fn set_stringtable(&self, data: &[u8]) -> ::std::io::Result<()> {
        self.storage.write("stringtable", schema::osm::resources::STRINGTABLE, data)
    }

}

impl OsmBuilder {
    pub fn new(
        storage: flatdata::StorageHandle,
    ) -> Result<Self, flatdata::ResourceStorageError> {
        flatdata::create_archive("Osm", schema::osm::OSM, &storage)?;
        Ok(Self { storage })
    }
}


#[doc(hidden)]
pub mod schema {
pub mod osm {

pub const OSM: &str = r#"namespace osm {
struct Header
{
    bbox_left : i64 : 40;
    bbox_right : i64 : 40;
    bbox_top : i64 : 40;
    bbox_bottom : i64 : 40;
    required_feature_first_idx : u64 : 40;
    required_features_size : u32 : 4;
    optional_feature_first_idx : u64 : 40;
    optional_features_size : u32 : 4;
    writingprogram_idx : u64 : 40;
    source_idx : u64 : 40;
    osmosis_replication_timestamp : i64 : 64;
    osmosis_replication_sequence_number : i64 : 64;
    osmosis_replication_base_url_idx : u64 : 40;
}
}

namespace osm {
struct Node
{
    id : i64 : 40;
    lat : i64 : 40;
    lon : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
}
}

namespace osm {
struct Way
{
    id : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
    @range( refs )
    ref_first_idx : u64 : 40;
}
}

namespace osm {
struct Relation
{
    id : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
}
}

namespace osm {
const u64 INVALID_IDX = 1099511627775;
}

namespace osm {
struct NodeMember
{
    @optional( .osm.INVALID_IDX )
    node_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
struct WayMember
{
    @optional( .osm.INVALID_IDX )
    way_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
struct RelationMember
{
    @optional( .osm.INVALID_IDX )
    relation_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
struct Tag
{
    key_idx : u64 : 40;
    value_idx : u64 : 40;
}
}

namespace osm {
struct TagIndex
{
    value : u64 : 40;
}
}

namespace osm {
struct NodeIndex
{
    @optional( .osm.INVALID_IDX )
    value : u64 : 40;
}
}

namespace osm {
const u64 COORD_SCALE = 1000000000;
}

namespace osm {
@bound_implicitly( Relations : .osm.Osm.relations, .osm.Osm.relation_members )
archive Osm
{
    @explicit_reference( .osm.Header.required_feature_first_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.optional_feature_first_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.writingprogram_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.source_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.osmosis_replication_base_url_idx, .osm.Osm.stringtable )
    header : .osm.Header;
    @explicit_reference( .osm.Node.tag_first_idx, .osm.Osm.tags_index )
    nodes : vector< .osm.Node >;
    @explicit_reference( .osm.Way.tag_first_idx, .osm.Osm.tags_index )
    @explicit_reference( .osm.Way.ref_first_idx, .osm.Osm.nodes_index )
    ways : vector< .osm.Way >;
    @explicit_reference( .osm.Relation.tag_first_idx, .osm.Osm.tags_index )
    relations : vector< .osm.Relation >;
    @explicit_reference( .osm.NodeMember.node_idx, .osm.Osm.nodes )
    @explicit_reference( .osm.NodeMember.role_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.WayMember.way_idx, .osm.Osm.ways )
    @explicit_reference( .osm.WayMember.role_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.RelationMember.relation_idx, .osm.Osm.relations )
    @explicit_reference( .osm.RelationMember.role_idx, .osm.Osm.stringtable )
    relation_members : multivector< 40, .osm.NodeMember, .osm.WayMember, .osm.RelationMember >;
    @explicit_reference( .osm.Tag.key_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Tag.value_idx, .osm.Osm.stringtable )
    tags : vector< .osm.Tag >;
    @explicit_reference( .osm.TagIndex.value, .osm.Osm.tags )
    tags_index : vector< .osm.TagIndex >;
    @explicit_reference( .osm.NodeIndex.value, .osm.Osm.nodes )
    nodes_index : vector< .osm.NodeIndex >;
    stringtable : raw_data;
}
}

"#;

pub mod resources {
pub const HEADER: &str = r#"namespace osm {
struct Header
{
    bbox_left : i64 : 40;
    bbox_right : i64 : 40;
    bbox_top : i64 : 40;
    bbox_bottom : i64 : 40;
    required_feature_first_idx : u64 : 40;
    required_features_size : u32 : 4;
    optional_feature_first_idx : u64 : 40;
    optional_features_size : u32 : 4;
    writingprogram_idx : u64 : 40;
    source_idx : u64 : 40;
    osmosis_replication_timestamp : i64 : 64;
    osmosis_replication_sequence_number : i64 : 64;
    osmosis_replication_base_url_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.Header.required_feature_first_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.optional_feature_first_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.writingprogram_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.source_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Header.osmosis_replication_base_url_idx, .osm.Osm.stringtable )
    header : .osm.Header;
}
}

"#;
pub const NODES: &str = r#"namespace osm {
struct Node
{
    id : i64 : 40;
    lat : i64 : 40;
    lon : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.Node.tag_first_idx, .osm.Osm.tags_index )
    nodes : vector< .osm.Node >;
}
}

"#;
pub const WAYS: &str = r#"namespace osm {
struct Way
{
    id : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
    @range( refs )
    ref_first_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.Way.tag_first_idx, .osm.Osm.tags_index )
    @explicit_reference( .osm.Way.ref_first_idx, .osm.Osm.nodes_index )
    ways : vector< .osm.Way >;
}
}

"#;
pub const RELATIONS: &str = r#"namespace osm {
struct Relation
{
    id : i64 : 40;
    @range( tags )
    tag_first_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.Relation.tag_first_idx, .osm.Osm.tags_index )
    relations : vector< .osm.Relation >;
}
}

"#;
pub const RELATION_MEMBERS: &str = r#"namespace osm {
const u64 INVALID_IDX = 1099511627775;
}

namespace osm {
struct NodeMember
{
    @optional( .osm.INVALID_IDX )
    node_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
struct WayMember
{
    @optional( .osm.INVALID_IDX )
    way_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
struct RelationMember
{
    @optional( .osm.INVALID_IDX )
    relation_idx : u64 : 40;
    role_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.NodeMember.node_idx, .osm.Osm.nodes )
    @explicit_reference( .osm.NodeMember.role_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.WayMember.way_idx, .osm.Osm.ways )
    @explicit_reference( .osm.WayMember.role_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.RelationMember.relation_idx, .osm.Osm.relations )
    @explicit_reference( .osm.RelationMember.role_idx, .osm.Osm.stringtable )
    relation_members : multivector< 40, .osm.NodeMember, .osm.WayMember, .osm.RelationMember >;
}
}

"#;
pub const TAGS: &str = r#"namespace osm {
struct Tag
{
    key_idx : u64 : 40;
    value_idx : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.Tag.key_idx, .osm.Osm.stringtable )
    @explicit_reference( .osm.Tag.value_idx, .osm.Osm.stringtable )
    tags : vector< .osm.Tag >;
}
}

"#;
pub const TAGS_INDEX: &str = r#"namespace osm {
struct TagIndex
{
    value : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.TagIndex.value, .osm.Osm.tags )
    tags_index : vector< .osm.TagIndex >;
}
}

"#;
pub const NODES_INDEX: &str = r#"namespace osm {
const u64 INVALID_IDX = 1099511627775;
}

namespace osm {
struct NodeIndex
{
    @optional( .osm.INVALID_IDX )
    value : u64 : 40;
}
}

namespace osm {
archive Osm
{
    @explicit_reference( .osm.NodeIndex.value, .osm.Osm.nodes )
    nodes_index : vector< .osm.NodeIndex >;
}
}

"#;
pub const STRINGTABLE: &str = r#"namespace osm {
archive Osm
{
    stringtable : raw_data;
}
}

"#;
}
}
}
}

#[doc(hidden)]
pub mod _builtin {

#[allow(missing_docs)]
pub mod multivector {

/// Builtin type to for MultiVector index
#[repr(transparent)]
pub struct IndexType40 {
    data: [u8; 5],
}

impl IndexType40 {
    /// Unsafe since the struct might not be self-contained
    pub unsafe fn new_unchecked( ) -> Self {
        Self{data : [0; 5]}
    }
}

impl flatdata::Struct for IndexType40 {
    unsafe fn create_unchecked( ) -> Self {
        Self{data : [0; 5]}
    }

    const SIZE_IN_BYTES: usize = 5;
    const IS_OVERLAPPING_WITH_NEXT : bool = true;
}

impl flatdata::Overlap for IndexType40 {}

impl IndexType40 {
    /// First element of the range [`range`].
    ///
    /// [`range`]: #method.range
    #[inline]
    pub fn value(&self) -> u64 {
        let value = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 40);
        unsafe { std::mem::transmute::<u64, u64>(value) }
    }

    #[inline]
    pub fn range(&self) -> std::ops::Range<u64> {
        let start = flatdata_read_bytes!(u64, self.data.as_ptr(), 0, 40);
        let end = flatdata_read_bytes!(u64, self.data.as_ptr(), 0 + 5 * 8, 40);
        start..end
    }

}

impl std::fmt::Debug for IndexType40 {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("IndexType40")
            .field("value", &self.value())
            .finish()
    }
}

impl std::cmp::PartialEq for IndexType40 {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.value() == other.value()     }
}

impl IndexType40 {
    /// First element of the range [`range`].
    ///
    /// [`range`]: struct.IndexType40Ref.html#method.range
    #[inline]
    #[allow(missing_docs)]
    pub fn set_value(&mut self, value: u64) {
        flatdata_write_bytes!(u64; value, self.data, 0, 40)
    }


    /// Copies the data from `other` into this struct.
    #[inline]
    pub fn fill_from(&mut self, other: &IndexType40) {
        self.set_value(other.value());
    }
}

impl flatdata::IndexStruct for IndexType40 {
    #[inline]
    fn range(&self) -> std::ops::Range<usize> {
        let range = self.range();
        range.start as usize..range.end as usize
    }

    #[inline]
    fn set_index(&mut self, value: usize) {
        self.set_value(value as u64);
    }
}


#[doc(hidden)]
pub mod schema {
}
}

#[doc(hidden)]
pub mod schema {
}
}
